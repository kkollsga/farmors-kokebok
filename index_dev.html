<!DOCTYPE html>
<html lang="no">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
<title>Farmors Oppskrifter</title>
<!-- iOS Web App -->
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="default">
<meta name="apple-mobile-web-app-title" content="Farmors Oppskrifter">

<!-- iOS Home Screen Icon (optional but recommended) -->
<!--  <link rel="apple-touch-icon" href="/icon-180.png"> -->

<script src="https://cdn.tailwindcss.com"></script>
<link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;700&family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">
<!-- Font Awesome -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
<style>
    /* ============================================
       BASE STYLES
    ============================================ */
    body { font-family: 'Inter', sans-serif; }
    body.modal-open { overflow: hidden; position: relative; touch-action: none; }
    .font-display { font-family: 'Playfair Display', serif; }
    
    /* ============================================
       SAFE AREA (iOS)
    ============================================ */
    .safe-bottom { padding-bottom: env(safe-area-inset-bottom, 0); }
    .safe-top { padding-top: env(safe-area-inset-top, 0); }
    
    /* ============================================
       SCROLLBAR STYLES
    ============================================ */
    .recipe-scroll::-webkit-scrollbar { width: 6px; }
    .recipe-scroll::-webkit-scrollbar-track { background: #f1f1f1; border-radius: 3px; }
    .recipe-scroll::-webkit-scrollbar-thumb { background: #d4d4d4; border-radius: 3px; }
    .recipe-scroll::-webkit-scrollbar-thumb:hover { background: #a8a8a8; }
    
    /* ============================================
       FILTER DROPDOWN
    ============================================ */
    #filterOptions { overscroll-behavior: contain; -webkit-overflow-scrolling: touch; }
    #filterOptions { background: linear-gradient(white 30%, rgba(255,255,255,0)) center top, linear-gradient(rgba(255,255,255,0), white 70%) center bottom, linear-gradient(white, white) center; background-size: 100% 40px, 100% 40px, 100% 100%; background-attachment: local, local, scroll; background-repeat: no-repeat; }
    
    /* ============================================
       ANIMATIONS
    ============================================ */
    @keyframes tipHighlight { from { transform: translateX(-10px); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
    @keyframes shimmer { 0% { background-position: -1000px 0; } 100% { background-position: 1000px 0; } }
    
    /* ============================================
       CARD TRANSITIONS
    ============================================ */
    [data-recipe-id] { transition: opacity 0.3s ease-out; }
    .recipe-counter { transition: transform 0.2s ease-out; }
    .recipe-stars i { transition: color 0.2s ease-out, transform 0.2s ease-out; }
    
    /* ============================================
       RECOMMENDATIONS CONTAINER
    ============================================ */
    #recommendedRecipes { transition: min-height 0.3s ease-out; position: relative; }
    #recommendedRecipes > div { transition: opacity 0.3s ease-out, transform 0.3s ease-out; }
    
    /* ============================================
       MODAL SCROLLING
    ============================================ */
    #recipeModal .absolute.inset-0 { -webkit-overflow-scrolling: touch; overscroll-behavior: contain; }
    #recipeModal .fixed.top-4.right-4 { transition: transform 0.2s ease-out; }
    #recipeModal .fixed.top-4.right-4:active { transform: scale(0.95); }
    #recipeModal .rounded-t-3xl { box-shadow: 0 -20px 40px rgba(0,0,0,0.3), 0 -10px 20px rgba(0,0,0,0.2); }
    
    /* ============================================
       DESKTOP MODAL
    ============================================ */
    @media (min-width: 901px) {
        #recipeModal .absolute.inset-0 { max-width: 1280px; margin: 0 auto; }
    }
    
    /* ============================================
       iOS SPECIFIC FIXES
    ============================================ */
    @supports (-webkit-touch-callout: none) {
        #recipeModal .absolute.inset-0 { -webkit-overflow-scrolling: touch; }
    }
</style>
</head>
<body class="bg-gradient-to-br from-orange-50 via-amber-50 to-yellow-50 min-h-screen">
<!-- Header -->
<header class="safe-top">
    <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-4">
        <div class="flex justify-between items-center">
            <h1 class="font-display text-3xl text-amber-800">Farmors Oppskrifter</h1>
        </div>
    </div>
</header>

 <!-- Search Bar -->
 <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 mt-8">
    <div class="bg-white/95 backdrop-blur rounded-2xl shadow-lg border border-white/50 p-1.5">
        <div class="relative">
            <i class="fas fa-search absolute left-4 top-1/2 transform -translate-y-1/2 text-gray-400"></i>
            <input type="text" id="searchInput" placeholder="S√∏k etter oppskrifter eller ingredienser..." 
                   class="modern-input w-full pl-12 pr-4 py-3 bg-gray-50/50 border-0 rounded-xl focus:outline-none focus:bg-white transition-all text-gray-700 placeholder-gray-400">
        </div>
    </div>
</div>

<!-- Filter Bar -->
<div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 mt-4">
    <div class="bg-white/95 backdrop-blur rounded-2xl shadow-lg border border-white/50 p-4">
        <div class="flex items-center gap-3">
            <!-- Filter Button -->
            <button id="filterToggle" onclick="recipeApp.filterManager.toggleFilterMenu()" 
                    class="flex items-center space-x-2 px-4 py-2 rounded-xl transition-all duration-200 text-sm font-medium shrink-0 shadow-sm hover:shadow-md">
                <i class="fas fa-filter transition-transform duration-200 active:scale-90"></i>
                <span>Filter</span>
                <span id="filterCount" class="hidden bg-white/30 text-white text-xs px-1.5 py-0.5 rounded-full font-semibold">0</span>
            </button>
            
            <!-- Filter Pills Container -->
            <div id="filterPillsContainer" class="flex gap-2 flex-1 overflow-hidden transition-[max-width,opacity] duration-300 ease-out whitespace-nowrap">
                <!-- Filter pills will be inserted here -->
            </div>
        </div>
    </div>
    
    <!-- Clear Filters Button (moved below) -->
    <div class="flex justify-end mt-2">
        <button id="clearFilters" onclick="recipeApp.filterManager.clearAllFilters()" 
                class="text-xs text-gray-500 hover:text-amber-600 transition-all duration-200 opacity-0 pointer-events-none font-medium px-3 py-1 rounded-lg hover:bg-white/80">
            T√∏m filter
        </button>
    </div>
    
    <!-- Filter Dropdown Menu -->
    <div id="filterMenu" class="relative">
        <div class="absolute top-2 left-0 bg-white rounded-xl shadow-[0_10px_25px_-5px_rgba(0,0,0,0.1),0_10px_10px_-5px_rgba(0,0,0,0.04)] border border-gray-100 z-30 hidden min-w-[280px] max-h-[400px] flex flex-col">
            <div class="text-sm font-semibold text-gray-700 px-4 pt-4 pb-2 border-b border-gray-100 flex-shrink-0">Velg kategorier</div>
            <div id="filterOptions" class="px-4 py-2 overflow-y-auto flex-1 recipe-scroll">
                <!-- Filter options will be inserted here -->
            </div>
        </div>
    </div>
</div>

<!-- Recommendations Section -->
<div id="recommendationsSection" class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 mt-6">
    <div id="recommendations" class="mb-8">
        <h2 class="font-display text-2xl text-amber-800 mb-4">Anbefalte for deg</h2>
        <div id="recommendedRecipes" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
            <!-- Recommended recipes will be inserted here -->
        </div>
    </div>
</div>

<!-- Main Recipe Grid -->
<div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 mt-8 pb-12 safe-bottom">
    <h2 class="font-display text-2xl text-amber-800 mb-4">Alle Oppskrifter</h2>
    <div id="recipeGrid" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
        <!-- Recipe cards will be inserted here -->
    </div>
</div>

<!-- Recipe Modal -->
<div id="recipeModal" class="fixed inset-0 bg-black bg-opacity-50 hidden z-50">
    <div class="flex items-start justify-center min-h-screen sm:pt-8">
        <div class="bg-red sm:rounded-3xl max-w-5xl w-full sm:h-[92vh] modal-height-mobile flex flex-col overflow-hidden modal-content-mobile">
            <div id="modalContent" class="h-full flex flex-col overflow-y-auto">
                <!-- Recipe content will be inserted here -->
            </div>
        </div>
    </div>
</div>

<script>
// ============================================================================
// CONFIGURATION CONSTANTS
// ============================================================================

const CONFIG = {
    BREAKPOINTS: {
        FULLSCREEN_MODAL: 1000,
        SINGLE_COLUMN: 600
    },
    IMAGE_PATHS: {
        LIST: 'images/full/',
        MODAL: 'images/full/'
    }
};

// ============================================================================
// RECIPE DATABASE CLASS
// ============================================================================

class RecipeDatabase {
    constructor() {
        this.recipes = [
            {"id":"recipe_1755485212305_4c4rynvqc","title":"Hjemmelaget saft","servings":"Ca. 4‚Äì5 liter saft","provider":"Farmor","reference":"Oppskriftsbok","pageNumber":69,"category":"Drikke","meal":"Drikke","cuisine":"Norsk","description":"En modernisert versjon av Farmors saftoppskrift uten konserveringsmidler. Du kan velge mellom kokt saft, som gir lang holdbarhet, eller r√•safting, som gir friskere smak men kortere holdbarhet. Begge metodene kan brukes p√• b√¶r eller hylleblomst.","ingredients":[{"group":"B√¶r eller blomster (velg √©n)","items":["2 kg solb√¶r","2 kg rips","2 kg bringeb√¶r","2 kg bl√•b√¶r","30 hylleblomstklaser"]},{"group":"For saftkoking","items":["6‚Äì8 dl vann","600‚Äì800 g sukker per liter ferdig silt saft"]},{"group":"For r√•safting","items":["2 sitroner i skiver (valgfritt)","30 g sitronsyre (ca. 2 ss)","1,5 liter vann","600‚Äì800 g sukker per liter ferdig silt saft"]}],"instructions":[{"group":"Koking","steps":["Skyll b√¶r eller hylleblomster godt og fjern alt som er r√•ttent.","Ha b√¶r/blomster og vann i en stor kjele. Kok forsiktig til de er bleke og saften har trukket ut.","Sil massen gjennom et saftklede og la det renne minst 1 time (helst over natten).","M√•l opp saften og tilsett 600‚Äì800 g sukker per liter silt saft.","Kok opp til sukkeret er oppl√∏st.","Hell den varme saften p√• sterile flasker, skru til korkene og avkj√∏l.","Oppbevar m√∏rkt og kj√∏lig. TIP: Frysing forlenger holdbarheten."]},{"group":"R√•safting","steps":["Skyll b√¶r eller hylleblomster godt og fjern alt som er r√•ttent.","Legg b√¶r/blomster i en stor bolle sammen med sitronskiver og sitronsyre.","Kok opp vann, hell over blandingen og dekk til.","La st√• kaldt i 2‚Äì3 d√∏gn, r√∏r om av og til.","Sil saften gjennom klede og m√•l opp v√¶sken.","Tilsett 600‚Äì800 g sukker per liter silt saft og r√∏r til sukkeret er helt oppl√∏st.","Hell p√• rene flasker og oppbevar kj√∏lig eller frys ned.","TIP: R√•saft egner seg godt som sommerdrikk, i cocktails eller som base til gel√©."]},"Bruk alltid rene redskaper og sterile flasker eller glass for best holdbarhet.","Oppbevar saften m√∏rkt og kj√∏lig, og merk flaskene med innhold og dato."]},
            {"id":"recipe_1755485212305_6c4rynvqc","title":"Berlinerkranser","servings":"Ca. 30‚Äì40 stk.","provider":"Farmor","reference":"Farmors oppskrifter","pageNumber":3,"category":"Julekaker","meal":"Snacks","cuisine":"Norsk","description":"Berlinerkranser er en klassisk norsk julekake laget av en sm√∏r- og eggeplommerik deig. De formes til sm√• kranser, pensles med eggehvite, dyppes i sukker og stekes til de er lett gylne. De har en spr√∏, s√∏t overflate og en sm√∏rm√∏r kjerne ‚Äì en fast tradisjon p√• norske kakefat i julen.","image":"berlinerkranser.png","ingredients":["250 g hvetemel","65 g sukker","145 g margarin eller sm√∏r","1 eggeplomme","1 eggehvite (til pensling)","perlesukker eller grovt sukker (til topping)"],"instructions":["Smuldre sammen hvetemel, sukker og margarin til en smuldrete blanding.","Tilsett eggeplommen og kna deigen godt sammen til en smidig deig.","Del deigen i sm√• emner og trill ut til fingertykke p√∏lser.","Form sm√• kranser og legg p√• et bakepapirkledd stekebrett.","Pensle kransene med lett pisket eggehvite.","Dypp oversiden i perlesukker eller grovt sukker.","Stek ved svak varme, ca. 175 ¬∞C, i 8‚Äì10 minutter til de er lett gylne.","Avkj√∏l p√• rist og oppbevar i tett kakeboks."],"createdAt":"2025-08-18"},
            {"id":"recipe_1755484726501_29ubmpget","title":"Rundstykker","servings":"ca. 16 rundstykker","provider":"Farmor","category":"Br√∏d","meal":"Frokost","cuisine":"Norsk","description":"Klassiske luftige rundstykker som passer perfekt til frokost, lunsj eller kveldsmat. Deigen er enkel √• lage, og med b√•de melk og sm√∏r f√•r du myke rundstykker med god smak. De er like gode nystekte som oppvarmet, og egner seg ogs√• godt til frysing.","image":"rundstykker.png","ingredients":["500 g hvetemel","1 pose t√∏rrgj√¶r (ca. 11 g)","50 g sm√∏r (romtemperert eller smeltet)","1 ¬Ω ts salt","2 dl melk (lunken, ca. 37‚Äì40 ¬∞C)","1 ¬Ω dl vann (lunkent, ca. 37‚Äì40 ¬∞C)","1 ss sukker"],"instructions":["Bland sammen hvetemel, t√∏rrgj√¶r, salt og sukker i en stor bolle.","Varm melk og vann til ca. 37‚Äì40 ¬∞C. Ha dette i melblandingen sammen med sm√∏ret.","Elt deigen i kj√∏kkenmaskin i 8‚Äì10 minutter (eller 12‚Äì15 minutter for h√•nd) til den er smidig og slipper bollen.","Dekk bollen med plast eller klede og la deigen heve p√• et lunt sted i ca. 1 time, til den har blitt dobbelt s√• stor.","Del deigen i ca. 16 emner og trill til runde boller. Legg dem p√• et stekebrett med bakepapir.","Etterhev rundstykkene i 30‚Äì40 minutter under klede.","Forvarm ovnen til 220 ¬∞C over-/undervarme. Stek rundstykkene midt i ovnen i 10‚Äì12 minutter til de er gylne og gjennomstekte.","Avkj√∏l p√• rist f√∏r servering."],"createdAt":"2025-08-18"}
        ];
    }

    findById(recipeId) {
        return this.recipes.find(recipe => recipe.id === recipeId);
    }

    getAllIds() {
        return this.recipes.map(r => r.id);
    }

    getAll() {
        return [...this.recipes];
    }

    getFilters() {
        const categories = new Set();
        const meals = new Set();
        const cuisines = new Set();
        
        this.recipes.forEach(recipe => {
            if (recipe.category) categories.add(recipe.category);
            if (recipe.meal) meals.add(recipe.meal);
            if (recipe.cuisine) cuisines.add(recipe.cuisine);
        });
        
        return {
            categories: Array.from(categories).sort(),
            meals: Array.from(meals).sort(),
            cuisines: Array.from(cuisines).sort()
        };
    }
}

// ============================================================================
// USER DATA MANAGER CLASS
// ============================================================================

class UserDataManager {
    constructor() {
        this.userData = {};
        this.load();
    }

    load() {
        const storedUserData = localStorage.getItem('userData');
        if (storedUserData) {
            this.userData = JSON.parse(storedUserData);
        }
    }

    save() {
        localStorage.setItem('userData', JSON.stringify(this.userData));
    }

    initializeRecipe(recipeId) {
        if (!this.userData[recipeId]) {
            this.userData[recipeId] = {
                userRating: null,
                madeDates: [],
                lastViewed: null,
                viewCount: 0,
                favorite: false
            };
        }
    }

    getRecipeData(recipeId) {
        return this.userData[recipeId] || {
            userRating: null,
            madeDates: [],
            lastViewed: null,
            viewCount: 0,
            favorite: false
        };
    }

    setRating(recipeId, rating) {
        this.initializeRecipe(recipeId);
        this.userData[recipeId].userRating = rating;
        this.save();
    }

    clearRating(recipeId) {
        if (this.userData[recipeId]) {
            this.userData[recipeId].userRating = null;
            this.save();
        }
    }

    toggleMadeToday(recipeId) {
        this.initializeRecipe(recipeId);
        const today = new Date().toISOString().split('T')[0];
        const madeDates = this.userData[recipeId].madeDates || [];
        
        const todayIndex = madeDates.indexOf(today);
        if (todayIndex > -1) {
            madeDates.splice(todayIndex, 1);
        } else {
            madeDates.push(today);
        }
        
        this.userData[recipeId].madeDates = madeDates;
        this.save();
        
        return {
            madeToday: madeDates.includes(today),
            madeCount: madeDates.length
        };
    }

    trackView(recipeId) {
        this.initializeRecipe(recipeId);
        this.userData[recipeId].lastViewed = new Date().toISOString();
        this.userData[recipeId].viewCount = (this.userData[recipeId].viewCount || 0) + 1;
        this.save();
    }

    getRecipeWithUserData(recipe) {
        const userInfo = this.getRecipeData(recipe.id);
        return { ...recipe, ...userInfo };
    }
}

// ============================================================================
// FILTER MANAGER CLASS
// ============================================================================

class FilterManager {
    constructor(recipeDatabase, uiManager) {
        this.recipeDatabase = recipeDatabase;
        this.uiManager = uiManager;
        this.activeFilters = new Map();
        this.filterMenuOpen = false;
        this.searchQuery = '';
    }

    setupEventListeners() {
        // Search input
        document.getElementById('searchInput').addEventListener('input', (e) => {
            this.searchQuery = e.target.value.toLowerCase();
            this.applyFilters();
            this.updateRecommendationsVisibility();
        });

        // Close filter menu on outside click
        document.addEventListener('click', (e) => {
            const menu = document.getElementById('filterMenu');
            const toggle = document.getElementById('filterToggle');
            
            if (this.filterMenuOpen && 
                !menu.contains(e.target) && 
                !toggle.contains(e.target)) {
                this.toggleFilterMenu();
            }
        });

        // Prevent body scroll when scrolling inside filter menu
        const filterMenu = document.getElementById('filterMenu');
        
        // Mouse wheel scrolling
        filterMenu.addEventListener('wheel', (e) => {
            const dropdown = filterMenu.querySelector('.absolute');
            if (dropdown && !dropdown.classList.contains('hidden')) {
                const filterOptions = document.getElementById('filterOptions');
                const isScrollable = filterOptions.scrollHeight > filterOptions.clientHeight;
                
                if (isScrollable) {
                    // Check if we're at the top or bottom of the scroll
                    const isAtTop = filterOptions.scrollTop === 0;
                    const isAtBottom = Math.abs(filterOptions.scrollTop + filterOptions.clientHeight - filterOptions.scrollHeight) < 1;
                    
                    // Prevent scroll propagation to body
                    if ((e.deltaY < 0 && isAtTop) || (e.deltaY > 0 && isAtBottom)) {
                        e.preventDefault();
                    } else {
                        e.stopPropagation();
                    }
                } else {
                    // If not scrollable, prevent all scrolling
                    e.preventDefault();
                }
            }
        }, { passive: false });

        // Touch scrolling for mobile
        let touchStartY = 0;
        
        filterMenu.addEventListener('touchstart', (e) => {
            const dropdown = filterMenu.querySelector('.absolute');
            if (dropdown && !dropdown.classList.contains('hidden')) {
                touchStartY = e.touches[0].clientY;
            }
        }, { passive: true });

        filterMenu.addEventListener('touchmove', (e) => {
            const dropdown = filterMenu.querySelector('.absolute');
            if (dropdown && !dropdown.classList.contains('hidden')) {
                const filterOptions = document.getElementById('filterOptions');
                const touchY = e.touches[0].clientY;
                const deltaY = touchStartY - touchY;
                
                const isAtTop = filterOptions.scrollTop === 0;
                const isAtBottom = Math.abs(filterOptions.scrollTop + filterOptions.clientHeight - filterOptions.scrollHeight) < 1;
                
                if ((deltaY < 0 && isAtTop) || (deltaY > 0 && isAtBottom)) {
                    e.preventDefault();
                }
            }
        }, { passive: false });
    }

    hasActiveSearchOrFilters() {
        return this.searchQuery.length > 0 || this.activeFilters.size > 0;
    }

    updateRecommendationsVisibility() {
        const recommendationsSection = document.getElementById('recommendationsSection');
        if (this.hasActiveSearchOrFilters()) {
            recommendationsSection.style.display = 'none';
        } else {
            recommendationsSection.style.display = 'block';
        }
    }

    activateFilter(filterType, filterValue, event) {
        if (event) {
            event.stopPropagation();
        }
        
        const filterKey = `${filterType}:${filterValue}`;
        
        // Close modal if it's open
        const modal = document.getElementById('recipeModal');
        if (!modal.classList.contains('hidden')) {
            window.recipeApp.modalManager.closeRecipe();
        }
        
        // Add filter if not already active
        if (!this.activeFilters.has(filterKey)) {
            this.activeFilters.set(filterKey, true);
            this.renderFilterPills();
            this.updateFilterButton();
            this.applyFilters();
            this.renderFilterOptions();
            this.updateRecommendationsVisibility();
        }
    }

    toggleFilterType(type) {
        if (this.activeFilters.has(type)) {
            this.activeFilters.delete(type);
        } else {
            this.activeFilters.set(type, true);
        }
        this.renderFilterPills();
        this.updateFilterButton();
        this.applyFilters();
        this.renderFilterOptions();
        this.updateRecommendationsVisibility();
    }

    togglePillActive(type) {
        if (this.activeFilters.has(type)) {
            this.activeFilters.set(type, !this.activeFilters.get(type));
            this.renderFilterPills();
            this.applyFilters();
        }
    }

    removeFilter(type) {
        this.activeFilters.delete(type);
        this.renderFilterPills();
        this.updateFilterButton();
        this.applyFilters();
        this.renderFilterOptions();
        this.updateRecommendationsVisibility();
    }

    clearAllFilters() {
        this.activeFilters.clear();
        this.renderFilterPills();
        this.updateFilterButton();
        this.applyFilters();
        this.renderFilterOptions();
        this.updateRecommendationsVisibility();
    }

    toggleFilterMenu() {
        const menu = document.querySelector('#filterMenu > div');
        
        if (!this.filterMenuOpen) {
            this.renderFilterOptions();
            menu.classList.remove('hidden');
            this.filterMenuOpen = true;
        } else {
            menu.classList.add('hidden');
            this.filterMenuOpen = false;
        }
    }

    renderFilterOptions() {
        const container = document.getElementById('filterOptions');
        const filters = this.recipeDatabase.getFilters();
        
        container.innerHTML = '';
        
        // Category filters
        if (filters.categories.length > 0) {
            const categoryHeader = document.createElement('div');
            categoryHeader.className = 'text-xs font-semibold text-gray-500 uppercase tracking-wider px-2 pt-1 pb-1 sticky top-0 bg-white z-10';
            categoryHeader.textContent = 'Kategori';
            container.appendChild(categoryHeader);
            
            filters.categories.forEach(category => {
                const isSelected = this.activeFilters.has(`category:${category}`);
                const option = document.createElement('label');
                option.className = 'flex items-center justify-between p-2 hover:bg-amber-50 rounded-lg cursor-pointer transition-colors';
                option.innerHTML = `
                    <span class="text-sm text-gray-700">${category}</span>
                    <input type="checkbox" 
                        ${isSelected ? 'checked' : ''} 
                        onchange="recipeApp.filterManager.toggleFilterType('category:${category}')"
                        onclick="event.stopPropagation()"
                        class="rounded border-gray-300 text-amber-600 focus:ring-amber-500 cursor-pointer checked:bg-amber-600 checked:border-amber-600">
                `;
                container.appendChild(option);
            });
        }
        
        // Meal filters
        if (filters.meals.length > 0) {
            const mealHeader = document.createElement('div');
            mealHeader.className = 'text-xs font-semibold text-gray-500 uppercase tracking-wider px-2 pt-3 pb-1 sticky top-0 bg-white z-10';
            mealHeader.textContent = 'M√•ltid';
            container.appendChild(mealHeader);
            
            filters.meals.forEach(meal => {
                const isSelected = this.activeFilters.has(`meal:${meal}`);
                const option = document.createElement('label');
                option.className = 'flex items-center justify-between p-2 hover:bg-amber-50 rounded-lg cursor-pointer transition-colors';
                option.innerHTML = `
                    <span class="text-sm text-gray-700">${meal}</span>
                    <input type="checkbox" 
                        ${isSelected ? 'checked' : ''} 
                        onchange="recipeApp.filterManager.toggleFilterType('meal:${meal}')"
                        onclick="event.stopPropagation()"
                        class="rounded border-gray-300 text-amber-600 focus:ring-amber-500 cursor-pointer checked:bg-amber-600 checked:border-amber-600">
                `;
                container.appendChild(option);
            });
        }
        
        // Cuisine filters
        if (filters.cuisines.length > 0) {
            const cuisineHeader = document.createElement('div');
            cuisineHeader.className = 'text-xs font-semibold text-gray-500 uppercase tracking-wider px-2 pt-3 pb-1 sticky top-0 bg-white z-10';
            cuisineHeader.textContent = 'Kj√∏kken';
            container.appendChild(cuisineHeader);
            
            filters.cuisines.forEach(cuisine => {
                const isSelected = this.activeFilters.has(`cuisine:${cuisine}`);
                const option = document.createElement('label');
                option.className = 'flex items-center justify-between p-2 hover:bg-amber-50 rounded-lg cursor-pointer transition-colors';
                option.innerHTML = `
                    <span class="text-sm text-gray-700">${cuisine}</span>
                    <input type="checkbox" 
                        ${isSelected ? 'checked' : ''} 
                        onchange="recipeApp.filterManager.toggleFilterType('cuisine:${cuisine}')"
                        onclick="event.stopPropagation()"
                        class="rounded border-gray-300 text-amber-600 focus:ring-amber-500 cursor-pointer checked:bg-amber-600 checked:border-amber-600">
                `;
                container.appendChild(option);
            });
        }
    }

    renderFilterPills() {
        const container = document.getElementById('filterPillsContainer');
        const hasFilters = this.activeFilters.size > 0;
        
        container.innerHTML = '';
        
        // Hide pills if more than 3 filters
        if (this.activeFilters.size > 3) {
            container.style.maxWidth = '0';
            container.style.opacity = '0';
        } else {
            container.style.maxWidth = hasFilters ? '100%' : '0';
            container.style.opacity = hasFilters ? '1' : '0';
            
            let pillCount = 0;
            this.activeFilters.forEach((isActive, filterKey) => {
                if (pillCount >= 3) return;
                
                const [filterType, filterValue] = filterKey.split(':');
                const displayName = filterValue || filterKey;
                
                const pill = document.createElement('div');
                pill.className = `inline-flex items-center gap-1 px-3 py-1.5 rounded-full text-sm transition-all shadow-sm max-w-[150px] ${
                    isActive 
                        ? 'bg-gradient-to-r from-amber-500 to-amber-600 text-white' 
                        : 'bg-gray-200 text-gray-500 opacity-60'
                }`;
                pill.innerHTML = `
                    <span class="cursor-pointer font-medium overflow-hidden text-ellipsis whitespace-nowrap max-w-[120px]" 
                            onclick="recipeApp.filterManager.togglePillActive('${filterKey}')">${displayName}</span>
                    <button onclick="recipeApp.filterManager.removeFilter('${filterKey}')" class="ml-1 hover:opacity-70 flex-shrink-0">
                        <i class="fas fa-times text-xs"></i>
                    </button>
                `;
                container.appendChild(pill);
                pillCount++;
            });
        }
        
        // Update clear button visibility
        const clearBtn = document.getElementById('clearFilters');
        if (hasFilters) {
            clearBtn.classList.remove('opacity-0', 'pointer-events-none');
            clearBtn.classList.add('opacity-100');
        } else {
            clearBtn.classList.add('opacity-0', 'pointer-events-none');
            clearBtn.classList.remove('opacity-100');
        }
    }

    updateFilterButton() {
        const btn = document.getElementById('filterToggle');
        const count = document.getElementById('filterCount');
        const hasFilters = this.activeFilters.size > 0;
        
        btn.className = 'flex items-center space-x-2 px-4 py-2 rounded-xl transition-all text-sm font-medium shrink-0 shadow-sm hover:shadow-md';
        
        if (hasFilters) {
            btn.classList.add('bg-gradient-to-r', 'from-amber-500', 'to-amber-600', 'text-white', 'hover:from-amber-600', 'hover:to-amber-700');
            count.textContent = this.activeFilters.size;
            count.classList.remove('hidden');
            count.classList.add('bg-white/30');
        } else {
            btn.classList.add('bg-white', 'text-gray-700', 'hover:text-amber-600', 'border', 'border-gray-200');
            count.classList.add('hidden');
        }
    }

    applyFilters() {
        let filtered = this.recipeDatabase.getAll();
        
        // Apply category/meal/cuisine filters
        const activeCategoryFilters = [];
        const activeMealFilters = [];
        const activeCuisineFilters = [];
        
        this.activeFilters.forEach((isActive, filterKey) => {
            if (!isActive) return;
            
            const [filterType, filterValue] = filterKey.split(':');
            if (filterType === 'category') {
                activeCategoryFilters.push(filterValue);
            } else if (filterType === 'meal') {
                activeMealFilters.push(filterValue);
            } else if (filterType === 'cuisine') {
                activeCuisineFilters.push(filterValue);
            }
        });
        
        // Filter by category
        if (activeCategoryFilters.length > 0) {
            filtered = filtered.filter(recipe => 
                activeCategoryFilters.includes(recipe.category)
            );
        }
        
        // Filter by meal type
        if (activeMealFilters.length > 0) {
            filtered = filtered.filter(recipe => 
                activeMealFilters.includes(recipe.meal)
            );
        }
        
        // Filter by cuisine type
        if (activeCuisineFilters.length > 0) {
            filtered = filtered.filter(recipe => 
                activeCuisineFilters.includes(recipe.cuisine)
            );
        }
        
        // Apply search filter
        if (this.searchQuery) {
            filtered = filtered.filter(recipe => {
                const titleMatch = recipe.title.toLowerCase().includes(this.searchQuery);
                
                let ingredientMatch = false;
                if (recipe.ingredients) {
                    recipe.ingredients.forEach(item => {
                        if (typeof item === 'string') {
                            if (item.toLowerCase().includes(this.searchQuery)) {
                                ingredientMatch = true;
                            }
                        } else if (item.items) {
                            item.items.forEach(ing => {
                                if (ing.toLowerCase().includes(this.searchQuery)) {
                                    ingredientMatch = true;
                                }
                            });
                        }
                    });
                }
                
                return titleMatch || ingredientMatch;
            });
        }
        
        const filteredIds = filtered.map(recipe => recipe.id);
        // Don't force full render when just filtering
        this.uiManager.renderRecipes(filteredIds, false);
    }
}

// ============================================================================
// UI MANAGER CLASS
// ============================================================================

class UIManager {
    constructor(recipeDatabase, userDataManager) {
        this.recipeDatabase = recipeDatabase;
        this.userDataManager = userDataManager;
        this.modalCallback = null; // Will be set later
    }

    setModalCallback(callback) {
        this.modalCallback = callback;
    }

    formatSource(recipe) {
        let parts = [];
        if (recipe.provider) {
            parts.push(recipe.provider);
        }
        if (recipe.reference) {
            parts.push(recipe.reference);
        }
        if (recipe.pageNumber) {
            parts.push(`s. ${recipe.pageNumber}`);
        }
        return parts.join(' ‚Ä¢ ');
    }

    renderStars(rating) {
        let stars = '';
        for (let i = 1; i <= 5; i++) {
            if (i <= rating) {
                stars += '<i class="fas fa-star text-amber-400 transition-all duration-200 hover:scale-125"></i>';
            } else {
                stars += '<i class="far fa-star text-gray-300 transition-all duration-200 hover:scale-125"></i>';
            }
        }
        return stars;
    }

    createRecipeCard(recipe) {
        const card = document.createElement('div');
        card.className = 'bg-white rounded-xl shadow-md overflow-hidden cursor-pointer hover:shadow-xl transition-all duration-300 hover:-translate-y-1';
        card.setAttribute('data-recipe-id', recipe.id);
        
        // Use data attribute instead of direct onclick
        card.setAttribute('data-recipe-click', recipe.id);
        
        const imageUrl = recipe.image ? CONFIG.IMAGE_PATHS.LIST + recipe.image : null;
        const sourceInfo = this.formatSource(recipe);
        
        card.innerHTML = `
            <div class="h-48 bg-gradient-to-br from-amber-100 to-orange-100 relative overflow-hidden">
                ${recipe.image ? 
                    `<img data-src="${imageUrl}" 
                        alt="${recipe.title}" 
                        class="w-full h-full object-cover opacity-0 transition-opacity duration-300">` : 
                    `<div class="w-full h-full flex items-center justify-center">
                        <span class="text-6xl opacity-30">üçû</span>
                    </div>`}
                ${recipe.category ? `<span onclick="recipeApp.filterManager.activateFilter('category', '${recipe.category}', event)" 
                    class="absolute top-2 right-2 bg-white/90 backdrop-blur text-xs font-medium px-2 py-1 rounded-full text-amber-700 transition-all duration-200 cursor-pointer hover:scale-105 hover:shadow-lg">
                    ${recipe.category}
                </span>` : ''}
            </div>
            <div class="p-5">
                <h3 class="font-display text-xl text-gray-800 ${sourceInfo ? 'mb-0' : 'mb-2'}">${recipe.title}</h3>
                ${sourceInfo ? `<p class="text-xs text-amber-600 mb-2">${sourceInfo}</p>` : ''}
                ${recipe.description ? `<p class="text-gray-500 text-xs mb-3 overflow-hidden line-clamp-2">${recipe.description}</p>` : ''}
                <div class="flex items-center justify-between gap-2">
                    <div class="recipe-stars flex items-center space-x-1 flex-shrink-0">
                        ${this.renderStars(recipe.userRating || 0)}
                    </div>
                    <div class="flex items-center gap-2 flex-wrap justify-end">
                        ${recipe.cuisine ? 
                            `<span onclick="recipeApp.filterManager.activateFilter('cuisine', '${recipe.cuisine}', event)" 
                                class="inline-block px-2 py-0.5 bg-gray-100 rounded-full text-xs cursor-pointer hover:bg-amber-100 transition-all duration-200 hover:scale-105">
                                ${recipe.cuisine}
                            </span>` : ''}
                        ${recipe.meal ? 
                            `<span onclick="recipeApp.filterManager.activateFilter('meal', '${recipe.meal}', event)" 
                                class="inline-block px-2 py-0.5 bg-gray-100 rounded-full text-xs cursor-pointer hover:bg-amber-100 transition-all duration-200 hover:scale-105">
                                ${recipe.meal}
                            </span>` : ''}
                        <div class="flex items-center ml-2 text-sm text-gray-600">
                            <i class="fas fa-utensils mr-1"></i>
                            <span class="recipe-counter">${recipe.madeDates ? recipe.madeDates.length : 0}</span>
                        </div>
                    </div>
                </div>
            </div>
        `;
        
        // Add loaded class once image loads
        const img = card.querySelector('img');
        if (img) {
            img.onload = () => img.classList.add('opacity-100');
        }
        
        return card;
    }

    renderRecipes(recipesToRender = null, forceFullRender = false) {
        const grid = document.getElementById('recipeGrid');
        const recipeIds = recipesToRender || this.recipeDatabase.getAllIds();
        
        // If force full render or grid is empty
        if (forceFullRender || grid.children.length === 0) {
            grid.innerHTML = '';
            recipeIds.forEach(recipeId => {
                const recipe = this.recipeDatabase.findById(recipeId);
                if (recipe) {
                    const recipeWithUserData = this.userDataManager.getRecipeWithUserData(recipe);
                    const card = this.createRecipeCard(recipeWithUserData);
                    grid.appendChild(card);
                }
            });
            this.setupLazyLoading();
            this.setupCardClickHandlers();
            return;
        }
        
        // Smart update: hide/show/reorder existing cards
        const existingCards = new Map();
        Array.from(grid.children).forEach(card => {
            const id = card.getAttribute('data-recipe-id');
            existingCards.set(id, card);
        });
        
        // Hide cards not in the filter
        existingCards.forEach((card, id) => {
            if (!recipeIds.includes(id)) {
                card.style.display = 'none';
            } else {
                card.style.display = '';
            }
        });
        
        // Reorder cards if needed
        const fragment = document.createDocumentFragment();
        recipeIds.forEach(recipeId => {
            if (existingCards.has(recipeId)) {
                const card = existingCards.get(recipeId);
                card.style.display = '';
                fragment.appendChild(card);
            } else {
                // Create new card if it doesn't exist
                const recipe = this.recipeDatabase.findById(recipeId);
                if (recipe) {
                    const recipeWithUserData = this.userDataManager.getRecipeWithUserData(recipe);
                    const card = this.createRecipeCard(recipeWithUserData);
                    fragment.appendChild(card);
                }
            }
        });
        
        grid.innerHTML = '';
        grid.appendChild(fragment);
        this.setupLazyLoading();
        this.setupCardClickHandlers();
    }

    setupCardClickHandlers() {
        // Setup click handlers for all recipe cards
        document.querySelectorAll('[data-recipe-click]').forEach(card => {
            card.onclick = (e) => {
                // Don't trigger if clicking on category filter
                if (e.target.closest('[onclick*="activateFilter"]')) {
                    return;
                }
                const recipeId = card.getAttribute('data-recipe-click');
                if (this.modalCallback) {
                    this.modalCallback(recipeId);
                }
            };
        });
    }

    setupLazyLoading() {
        const imageObserver = new IntersectionObserver((entries, observer) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    const img = entry.target;
                    const src = img.getAttribute('data-src');
                    
                    if (src) {
                        const newImg = new Image();
                        newImg.onload = () => {
                            img.src = src;
                            img.classList.add('opacity-100');
                            img.removeAttribute('data-src');
                        };
                        newImg.src = src;
                    }
                    observer.unobserve(img);
                }
            });
        }, {
            rootMargin: '50px'
        });

        document.querySelectorAll('img[data-src]').forEach(img => {
            imageObserver.observe(img);
        });
    }

    updateRecipeCardRating(recipeId, rating) {
        const cards = document.querySelectorAll(`[data-recipe-id="${recipeId}"]`);
        cards.forEach(card => {
            const stars = card.querySelectorAll('.recipe-stars i');
            stars.forEach((star, index) => {
                if (index < rating) {
                    star.classList.remove('far', 'text-gray-300');
                    star.classList.add('fas', 'text-amber-400');
                } else {
                    star.classList.remove('fas', 'text-amber-400');
                    star.classList.add('far', 'text-gray-300');
                }
            });
        });
    }

    updateRecipeCardCounter(recipeId, count) {
        const cards = document.querySelectorAll(`[data-recipe-id="${recipeId}"]`);
        cards.forEach(card => {
            const counterElement = card.querySelector('.recipe-counter');
            if (counterElement && counterElement.textContent !== count.toString()) {
                counterElement.textContent = count;
                // Add a subtle animation
                counterElement.style.transform = 'scale(1.2)';
                setTimeout(() => {
                    counterElement.style.transform = 'scale(1)';
                }, 200);
            }
        });
    }
}

// ============================================================================
// MODAL MANAGER CLASS
// ============================================================================

class ModalManager {
    constructor(recipeDatabase, userDataManager, uiManager, recommendationEngine) {
        this.recipeDatabase = recipeDatabase;
        this.userDataManager = userDataManager;
        this.uiManager = uiManager;
        this.recommendationEngine = recommendationEngine;
        this.scrollPosition = 0;
        this.isFullscreen = false;
        this.currentRecipeId = null;
        this.completedSteps = new Map();
        this.activeStep = null;
        this.setupEventListeners();
    }

    setupEventListeners() {
        // Close modal on outside click (only when not fullscreen)
        document.getElementById('recipeModal').addEventListener('click', (e) => {
            // Check current window width directly instead of relying on stored state
            const currentlyFullscreen = window.innerWidth <= CONFIG.BREAKPOINTS.FULLSCREEN_MODAL;
            if (!currentlyFullscreen) {
                // Use position-based selector for modal wrapper
                const modalWrapper = e.currentTarget.firstElementChild?.firstElementChild;
                if (modalWrapper && !modalWrapper.contains(e.target)) {
                    this.closeRecipe();
                }
            }
        });

        // Handle window resize - IMMEDIATE updates
        window.addEventListener('resize', () => {
            if (this.currentRecipeId) {
                // Immediately update layout and content for smooth transitions
                this.updateModalLayout();
                this.updateModalContent();
            }
        });
        
        // Prevent zoom on iOS rotation
        window.addEventListener('orientationchange', (e) => {
            if (this.currentRecipeId) {
                // Prevent default zoom behavior
                e.preventDefault();
                
                // Force viewport reset
                const viewport = document.querySelector('meta[name="viewport"]');
                viewport.setAttribute('content', 
                    'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover'
                );
                
                // Small delay to ensure proper layout update
                setTimeout(() => {
                    this.updateModalLayout();
                    this.updateModalContent();
                }, 100);
            }
        });
    }

    // Main entry point for showing a recipe
    showRecipe(recipeId) {
        const recipe = this.recipeDatabase.findById(recipeId);
        if (!recipe) return;
        
        this.currentRecipeId = recipeId;
        
        // Clear completed steps and active step for this recipe when opening
        Array.from(this.completedSteps.keys()).forEach(key => {
            if (key.startsWith(recipeId + '-')) {
                this.completedSteps.delete(key);
            }
        });
        if (this.activeStep && this.activeStep.startsWith(recipeId + '-')) {
            this.activeStep = null;
        }
        
        // Track view
        this.userDataManager.trackView(recipeId);
        
        // Lock body scroll - UPDATED APPROACH
        this.scrollPosition = window.pageYOffset;
        document.body.classList.add('modal-open');
        
        // For iOS, prevent scroll on the body
        document.body.style.overflow = 'hidden';
        document.body.style.position = 'relative';
        document.documentElement.style.overflow = 'hidden'; // Also lock html element
        
        // Setup modal layout (fullscreen vs windowed)
        this.setupModalLayout();
        
        // Generate and insert content
        this.updateModalContent();
        
        // Make modal visible
        const modal = document.getElementById('recipeModal');
        modal.classList.remove('hidden');
    }

    // Separate function to handle modal container layout
    setupModalLayout() {
        const modal = document.getElementById('recipeModal');
        const flexContainer = modal.firstElementChild;
        const modalWrapper = flexContainer ? flexContainer.firstElementChild : null;
        
        const windowWidth = window.innerWidth;
        this.isFullscreen = windowWidth <= CONFIG.BREAKPOINTS.FULLSCREEN_MODAL;
        
        if (this.isFullscreen) {
            // Fullscreen mode - no backdrop, fill entire viewport
            modal.className = 'fixed inset-0 z-50 bg-gradient-to-br from-amber-100 to-orange-100';  // Add gradient here
            
            // Remove flex container or make it passthrough
            if (flexContainer) {
                flexContainer.className = 'h-full';
            }
            
            // Modal wrapper becomes full viewport
            if (modalWrapper) {
                modalWrapper.className = 'h-full w-full flex flex-col relative';
            }
            
        } else {
            // Desktop modal with backdrop
            modal.className = 'fixed inset-0 bg-black bg-opacity-50 z-50';
            
            // Flex container for centering
            if (flexContainer) {
                flexContainer.className = 'flex items-center justify-center min-h-screen p-4';
            }
            
            // Modal wrapper - Add a base background color
            if (modalWrapper) {
                modalWrapper.className = 'bg-gradient-to-br from-amber-100 to-orange-100 rounded-3xl max-w-5xl w-full h-[92vh] flex flex-col shadow-2xl relative overflow-hidden';
                // Added gradient background to the wrapper itself
            }
        }
    }

    // Update just the modal layout without regenerating content
    updateModalLayout() {
        if (this.currentRecipeId) {
            this.setupModalLayout();
        }
    }

    // Generate hero section (shared between mobile and desktop)
    generateHeroSection(recipe) {
        const imageUrl = recipe.image ? CONFIG.IMAGE_PATHS.MODAL + recipe.image : null;
        const isMobile = window.innerWidth <= CONFIG.BREAKPOINTS.SINGLE_COLUMN;
        const heroImageHeight = isMobile ? 'h-56' : 'h-80';
        const isFullscreen = window.innerWidth <= CONFIG.BREAKPOINTS.FULLSCREEN_MODAL;
        
        return `
            <!-- Full modal background with rounded corners for desktop -->
            <div class="absolute inset-0 bg-gradient-to-br from-amber-100 to-orange-100 ${!isFullscreen ? 'rounded-2xl' : ''} z-0">
                <!-- Hero image at the top -->
                <div class="absolute inset-x-0 top-0 ${heroImageHeight} ${!isFullscreen ? 'rounded-t-2xl overflow-hidden' : ''}">
                    ${recipe.image ? 
                        `<img src="${imageUrl}" alt="${recipe.title}" class="w-full h-full object-cover">` : 
                        `<div class="w-full h-full flex items-center justify-center">
                            <span class="text-8xl opacity-30">üçû</span>
                        </div>`}
                    ${recipe.category ? 
                        `<span onclick="recipeApp.filterManager.activateFilter('category', '${recipe.category}', event)" 
                            class="absolute top-4 left-4 bg-white/90 backdrop-blur text-xs md:text-sm font-medium px-2 py-1 md:px-3 md:py-1.5 rounded-full text-amber-700 transition-all duration-200 cursor-pointer hover:scale-105 hover:shadow-lg">
                            ${recipe.category}
                        </span>` : ''}
                </div>
            </div>
        `;
    }

    // Generate close button (shared between mobile and desktop)
    generateCloseButton() {
        return `
            <button onclick="recipeApp.modalManager.closeRecipe()" 
                    class="absolute top-4 right-4 z-50 bg-white/90 backdrop-blur rounded-full p-2 md:p-2.5 hover:bg-white shadow-lg transition-transform hover:scale-110">
                <i class="fas fa-times text-gray-600 text-lg md:text-xl"></i>
            </button>
        `;
    }

    // Separate function to handle content generation
    updateModalContent() {
        if (!this.currentRecipeId) return;
        
        const recipe = this.recipeDatabase.findById(this.currentRecipeId);
        if (!recipe) return;
        
        const recipeWithUserData = this.userDataManager.getRecipeWithUserData(recipe);
        const modalWrapper = document.querySelector('#recipeModal > div > div');
        
        if (!modalWrapper) return;
        
        // Store current scroll position before updating
        const scrollContainer = modalWrapper.querySelector('#scrollableContent');
        const currentScrollTop = scrollContainer ? scrollContainer.scrollTop : 0;
        
        // Determine content layout (mobile vs desktop)
        const windowWidth = window.innerWidth;
        const isMobileLayout = windowWidth <= CONFIG.BREAKPOINTS.SINGLE_COLUMN;
        const heroHeight = isMobileLayout ? '14rem' : '20rem'; // h-56 = 14rem, h-80 = 20rem
        const contentMarginTop = isMobileLayout ? 'mt-48' : 'mt-72'; // Slightly less than hero height for overlap
        
        // Build the complete modal content structure
        modalWrapper.innerHTML = `
            ${this.generateHeroSection(recipeWithUserData)}
            ${this.generateCloseButton()}
            <div id="scrollableContent" class="absolute inset-0 overflow-y-auto z-10">
                <div class="${contentMarginTop} min-h-full bg-white rounded-t-3xl shadow-[0_-10px_30px_rgba(0,0,0,0.1)]">
                    ${isMobileLayout ? 
                        this.generateMobileContent(recipeWithUserData) : 
                        this.generateDesktopContent(recipeWithUserData)}
                </div>
            </div>
        `;
        
        // Restore scroll position after content update
        requestAnimationFrame(() => {
            const newScrollContainer = modalWrapper.querySelector('#scrollableContent');
            if (newScrollContainer && currentScrollTop > 0) {
                newScrollContainer.scrollTop = currentScrollTop;
            }
        });
    }

    // Mobile content layout (single column, optimized for touch)
    generateMobileContent(recipe) {
        const sourceInfo = this.uiManager.formatSource(recipe);
        const today = new Date().toISOString().split('T')[0];
        const madeToday = recipe.madeDates && recipe.madeDates.includes(today);
        const madeCount = recipe.madeDates ? recipe.madeDates.length : 0;
        
        return `
            <div class="px-4 py-6">
                <!-- Title and metadata -->
                <div class="mb-4">
                    <h2 class="font-display text-2xl text-gray-800 ${sourceInfo ? 'mb-1' : 'mb-2'}">${recipe.title}</h2>
                    ${sourceInfo ? `<p class="text-xs text-amber-600 mb-2">${sourceInfo}</p>` : ''}
                    ${this.renderTags(recipe)}
                </div>
                
                <!-- Actions -->
                <div class="flex items-center justify-between mb-4">
                    <div class="flex items-center gap-2">
                        <button id="eraser-${recipe.id}" 
                                onclick="recipeApp.modalManager.clearRating('${recipe.id}', event)" 
                                class="text-gray-400 hover:text-gray-600 transition-all duration-200 p-1 ${recipe.userRating ? 'opacity-100' : 'opacity-0 pointer-events-none'}">
                            <i class="fas fa-eraser text-lg"></i>
                        </button>
                        <div class="flex items-center">
                            ${this.renderInteractiveStars(recipe)}
                        </div>
                    </div>
                    <button onclick="recipeApp.modalManager.toggleMadeToday('${recipe.id}', event)" 
                            class="flex items-center space-x-1 px-3 py-1.5 rounded-lg transition text-xs font-medium
                                ${madeToday ? 'bg-amber-600 text-white' : 'border border-gray-300 text-gray-600 hover:bg-gray-50'}">
                        <i class="fas fa-check"></i>
                        <span>Laget (${madeCount})</span>
                    </button>
                </div>
                
                <!-- Description -->
                ${recipe.description ? `
                    <div class="pb-4 mb-6 border-b border-amber-600">
                        <p class="text-gray-700 text-sm leading-relaxed">${recipe.description}</p>
                    </div>
                ` : ''}
                
                <!-- Ingredients -->
                <div class="mb-6 pb-6 border-b border-amber-600">
                    <h3 class="font-display text-xl text-amber-800 mb-3">Ingredienser</h3>
                    ${this.renderIngredients(recipe.ingredients)}
                    <div class="mt-4 flex items-center gap-2 text-amber-600 rounded-lg px-3 py-2 inline-flex">
                        <i class="fas fa-users text-sm"></i>
                        <span class="text-sm font-medium">${recipe.servings}</span>
                    </div>
                </div>
                
                <!-- Instructions -->
                <div class="mb-8">
                    <h3 class="font-display text-xl text-amber-800 mb-3">Slik gj√∏r du</h3>
                    ${this.renderInstructions(recipe.instructions, true)}
                </div>
            </div>
        `;
    }

    // Desktop content layout (two columns, more spacious)
    generateDesktopContent(recipe) {
        const sourceInfo = this.uiManager.formatSource(recipe);
        const today = new Date().toISOString().split('T')[0];
        const madeToday = recipe.madeDates && recipe.madeDates.includes(today);
        const madeCount = recipe.madeDates ? recipe.madeDates.length : 0;
        
        return `
            <div class="px-8 py-8">
                <!-- Header section -->
                <div class="border-b border-gray-100 pb-4 mb-6">
                    <h2 class="font-display text-3xl text-gray-800 ${sourceInfo ? 'mb-1' : 'mb-2'}">${recipe.title}</h2>
                    ${sourceInfo ? `<p class="text-sm text-amber-600 mb-2">${sourceInfo}</p>` : ''}
                    ${this.renderTags(recipe)}
                    
                    <!-- Actions row -->
                    <div class="flex items-center justify-between">
                        <div class="flex items-center gap-4">
                            <!-- Rating -->
                            <div class="flex items-center gap-2">
                                <button id="eraser-${recipe.id}" 
                                        onclick="recipeApp.modalManager.clearRating('${recipe.id}', event)" 
                                        class="text-gray-400 hover:text-gray-600 transition-all duration-200 p-1 ${recipe.userRating ? 'opacity-100' : 'opacity-0 pointer-events-none'}">
                                    <i class="fas fa-eraser text-xl"></i>
                                </button>
                                <div class="flex items-center gap-1">
                                    ${this.renderInteractiveStars(recipe)}
                                </div>
                            </div>
                        </div>
                        
                        <!-- Made button -->
                        <button onclick="recipeApp.modalManager.toggleMadeToday('${recipe.id}', event)" 
                                class="flex items-center space-x-2 px-4 py-2 rounded-lg transition text-sm font-medium
                                    ${madeToday ? 'bg-amber-600 text-white hover:bg-amber-700' : 'border border-gray-300 text-gray-600 hover:bg-gray-50'}">
                            <i class="fas fa-check"></i>
                            <span>Laget (${madeCount})</span>
                        </button>
                    </div>
                </div>
                
                <!-- Description -->
                ${recipe.description ? `
                    <div class="pb-6 mb-6 border-b border-amber-600">
                        <p class="text-gray-700 leading-relaxed">${recipe.description}</p>
                    </div>
                ` : ''}
                
                <!-- Two column layout for ingredients and instructions -->
                <div class="grid md:grid-cols-[2fr,3fr] gap-8">
                    <div class="pr-8 border-r border-amber-600">
                        <h3 class="font-display text-xl text-amber-800 mb-4">Ingredienser</h3>
                        ${this.renderIngredients(recipe.ingredients)}
                        <div class="mt-4 flex items-center gap-2 text-amber-600 rounded-lg px-3 py-2 inline-flex">
                            <i class="fas fa-users"></i>
                            <span class="font-medium">${recipe.servings}</span>
                        </div>
                    </div>
                    
                    <div>
                        <h3 class="font-display text-xl text-amber-800 mb-4">Slik gj√∏r du</h3>
                        ${this.renderInstructions(recipe.instructions, false)}
                    </div>
                </div>
            </div>
        `;
    }

    // Helper to render tags (cuisine, meal)
    renderTags(recipe) {
        if (!recipe.cuisine && !recipe.meal) return '';
        
        return `
            <div class="flex gap-2 mb-4">
                ${recipe.cuisine ? 
                    `<span onclick="recipeApp.filterManager.activateFilter('cuisine', '${recipe.cuisine}', event)" 
                        class="inline-block px-2 py-0.5 bg-gray-100 rounded-full text-xs">
                        ${recipe.cuisine} kj√∏kken
                    </span>` : ''}
                ${recipe.meal ? 
                    `<span onclick="recipeApp.filterManager.activateFilter('meal', '${recipe.meal}', event)" 
                        class="inline-block px-2 py-0.5 bg-gray-100 rounded-full text-xs">
                        ${recipe.meal}
                    </span>` : ''}
            </div>
        `;
    }

    renderIngredients(ingredients) {
        if (!ingredients || ingredients.length === 0) return '';
        
        const hasGroups = ingredients.some(item => typeof item === 'object' && item.group);
        
        if (!hasGroups) {
            return `
                <ul class="space-y-2">
                    ${ingredients.map(ing => `
                        <li class="flex items-start">
                            <span class="text-amber-600 mr-2">‚Ä¢</span>
                            <span class="text-gray-700">${ing}</span>
                        </li>
                    `).join('')}
                </ul>
            `;
        } else {
            return ingredients.map((group, index) => {
                if (typeof group === 'string') {
                    return `
                        <ul class="space-y-2 ${index > 0 ? 'mt-4' : ''}">
                            <li class="flex items-start">
                                <span class="text-amber-600 mr-2">‚Ä¢</span>
                                <span class="text-gray-700">${group}</span>
                            </li>
                        </ul>
                    `;
                }
                
                return `
                    <div class="${index > 0 ? 'mt-5' : ''}">
                        <h4 class="font-semibold text-sm text-amber-700 mb-2">${group.group}:</h4>
                        <ul class="space-y-2">
                            ${group.items.map(ing => `
                                <li class="flex items-start">
                                    <span class="text-amber-600 mr-2">‚Ä¢</span>
                                    <span class="text-gray-700">${ing}</span>
                                </li>
                            `).join('')}
                        </ul>
                    </div>
                `;
            }).join('');
        }
    }

    toggleInstructionStep(recipeId, stepIndex) {
        const key = `${recipeId}-${stepIndex}`;
        const isCompleted = this.completedSteps.get(key) || false;
        const isActive = this.activeStep === key;
        
        const stepElement = document.querySelector(`[data-step="${key}"]`);
        if (!stepElement) return;
        
        // Clear previous active step visually if switching to a new step
        if (this.activeStep && this.activeStep !== key) {
            const prevElement = document.querySelector(`[data-step="${this.activeStep}"]`);
            if (prevElement && !this.completedSteps.get(this.activeStep)) {
                prevElement.parentElement.classList.remove('bg-amber-50', 'border-l-4', 'border-amber-500', 'pl-4', 'pr-0');
                prevElement.parentElement.classList.add('pr-2');
                prevElement.classList.remove('text-black');
                prevElement.classList.add('text-gray-700');
            }
        }
        
        if (!isActive && !isCompleted) {
            // Default ‚Üí Active
            this.activeStep = key;
            this.completedSteps.delete(key);
            stepElement.classList.remove('line-through', 'text-gray-400');
            stepElement.classList.remove('text-gray-700');
            stepElement.classList.add('text-black');
            stepElement.parentElement.classList.add('bg-amber-50', 'border-l-4', 'border-amber-500', 'pl-4', 'pr-0');
            stepElement.parentElement.classList.remove('pr-2');
        } else if (isActive && !isCompleted) {
            // Active ‚Üí Completed
            this.completedSteps.set(key, true);
            this.activeStep = null;
            stepElement.classList.add('line-through', 'text-gray-400');
            stepElement.classList.remove('text-black');
            stepElement.parentElement.classList.remove('bg-amber-50', 'border-l-4', 'border-amber-500', 'pl-4', 'pr-0');
            stepElement.parentElement.classList.add('pr-2');
        } else if (isCompleted) {
            // Completed ‚Üí Active
            this.completedSteps.delete(key);
            this.activeStep = key;
            stepElement.classList.remove('line-through', 'text-gray-400');
            stepElement.classList.add('text-black');
            stepElement.parentElement.classList.add('bg-amber-50', 'border-l-4', 'border-amber-500', 'pl-4', 'pr-0');
            stepElement.parentElement.classList.remove('pr-2');
        }
    }

    // Add these helper methods to the ModalManager class:
    renderTip(tipText, isMobile) {
        const textSizeClass = isMobile ? 'text-sm' : '';
        return `
            <li class="bg-gradient-to-r from-yellow-100 to-yellow-50 border-l-[3px] border-amber-500 rounded-lg ${isMobile ? 'px-3 py-2.5' : 'p-3'} animate-[tipHighlight_0.3s_ease-out]">
                <div class="flex items-start">
                    <span class="text-amber-600 mr-2 flex-shrink-0">
                        <i class="fas fa-lightbulb"></i>
                    </span>
                    <div>
                        <span class="font-semibold text-amber-700 mr-2 text-sm">Tips:</span>
                        <span class="text-gray-700 ${textSizeClass}">${tipText}</span>
                    </div>
                </div>
            </li>
        `;
    }

    renderInstructionStep(instruction, stepNumber, globalIndex, isMobile) {
        const recipeId = this.currentRecipeId;
        const textSizeClass = isMobile ? 'text-sm' : '';
        const stepKey = `${recipeId}-${globalIndex}`;
        const isCompleted = this.completedSteps.get(stepKey) || false;
        const isActive = this.activeStep === stepKey;
        
        return `
            <li class="flex items-start cursor-pointer select-none transition-all duration-200 hover:opacity-80 rounded-lg py-2 pl-2 ${isActive ? 'pr-0' : 'pr-2'} -m-2 
                ${isActive ? 'bg-amber-50 border-l-4 border-amber-500 pl-4' : ''}"
                onclick="recipeApp.modalManager.toggleInstructionStep('${recipeId}', ${globalIndex})">
                <span class="font-semibold text-amber-600 mr-3 flex-shrink-0">${stepNumber}.</span>
                <span data-step="${stepKey}" 
                    class="${textSizeClass} ${isCompleted ? 'line-through text-gray-400' : (isActive ? 'text-black' : 'text-gray-700')} transition-all duration-200">
                    ${instruction}
                </span>
            </li>
        `;
    }

    renderInstructionItem(instruction, stepNumber, globalIndex, isMobile) {
        // Check if it's a tip
        if (typeof instruction === 'string' && (instruction.startsWith('TIP:') || instruction.startsWith('TIPS:'))) {
            const tipText = instruction.replace(/^TIPS?:\s*/i, '');
            return { 
                html: this.renderTip(tipText, isMobile), 
                stepNumber: stepNumber,
                globalIndex: globalIndex 
            };
        }
        
        // Regular instruction step
        return { 
            html: this.renderInstructionStep(instruction, stepNumber, globalIndex, isMobile),
            stepNumber: stepNumber + 1,
            globalIndex: globalIndex + 1
        };
    }

    renderInstructions(instructions, isMobile = false) {
        if (!instructions || instructions.length === 0) return '';
        
        let stepNumber = 1;
        let globalIndex = 0;
        
        // Check if we have grouped instructions
        const hasGroups = instructions.some(item => typeof item === 'object' && item.group);
        
        // Simple flat instructions
        if (!hasGroups) {
            const items = [];
            instructions.forEach(inst => {
                const result = this.renderInstructionItem(inst, stepNumber, globalIndex, isMobile);
                items.push(result.html);
                stepNumber = result.stepNumber;
                globalIndex = result.globalIndex;
            });
            
            return `<ol class="space-y-3">${items.join('')}</ol>`;
        }
        
        // Grouped instructions
        const sections = [];
        
        instructions.forEach((item, index) => {
            if (typeof item === 'string') {
                // Single instruction outside a group
                const result = this.renderInstructionItem(item, stepNumber, globalIndex, isMobile);
                sections.push(`<ol class="space-y-3 ${index > 0 ? 'mt-3' : ''}">${result.html}</ol>`);
                stepNumber = result.stepNumber;
                globalIndex = result.globalIndex;
            } else if (item.group && item.steps) {
                // Group of instructions with indent and tighter spacing
                const groupItems = [];
                item.steps.forEach(inst => {
                    const result = this.renderInstructionItem(inst, stepNumber, globalIndex, isMobile);
                    groupItems.push(result.html);
                    stepNumber = result.stepNumber;
                    globalIndex = result.globalIndex;
                });
                
                sections.push(`
                    <div class="${index > 0 ? 'mt-4' : ''}">
                        <h4 class="font-semibold text-sm text-amber-700 mb-2">${item.group}:</h4>
                        <ol class="space-y-2 ${isMobile ? 'pl-3' : 'pl-4'}">
                            ${groupItems.join('')}
                        </ol>
                    </div>
                `);
            }
        });
        
        return sections.join('');
    }

    renderInteractiveStars(recipe) {
        let stars = '';
        const userRating = recipe.userRating || 0;
        for (let i = 1; i <= 5; i++) {
            const filled = i <= userRating;
            stars += `<button onclick="recipeApp.modalManager.rateRecipe('${recipe.id}', ${i}, event)" 
                            class="text-2xl transition-all duration-200 hover:scale-125 hover:text-amber-500">
                <i class="${filled ? 'fas' : 'far'} fa-star ${filled ? 'text-amber-400' : 'text-gray-300'}"></i>
            </button>`;
        }
        return stars;
    }

    closeRecipe() {
        const modal = document.getElementById('recipeModal');
        
        // Clear current recipe
        this.currentRecipeId = null;
        this.isFullscreen = false;
        
        // Hide modal
        modal.classList.add('hidden');
        
        // Restore body scroll - UPDATED APPROACH
        document.body.classList.remove('modal-open');
        document.body.style.overflow = '';
        document.body.style.position = '';
        document.documentElement.style.overflow = ''; // Restore html element
        // Remove the line that resets body.style.top
        // document.body.style.top = ''; // REMOVE THIS
        window.scrollTo(0, this.scrollPosition);
        
        // Reset modal classes to default state
        this.resetModalToDefault();
    }

    // Reset modal to default state (for next opening)
    resetModalToDefault() {
        const modal = document.getElementById('recipeModal');
        const flexContainer = modal.firstElementChild;
        const modalWrapper = flexContainer ? flexContainer.firstElementChild : null;
        
        // Reset to default classes
        modal.className = 'fixed inset-0 bg-black bg-opacity-50 hidden z-50';
        
        if (flexContainer) {
            flexContainer.className = 'flex items-start justify-center min-h-screen sm:pt-8';
        }
        
        if (modalWrapper) {
            // Removed bg-white from here too
            modalWrapper.className = 'sm:rounded-2xl max-w-5xl w-full sm:h-[92vh] modal-height-mobile flex flex-col modal-content-mobile';
            modalWrapper.innerHTML = '';
        }
    }

    rateRecipe(recipeId, rating, event) {
        if (event) {
            event.stopPropagation();
        }
        
        this.userDataManager.setRating(recipeId, rating);
        
        // Update stars in modal
        const button = event ? event.currentTarget : null;
        if (button && button.parentElement) {
            const stars = button.parentElement.querySelectorAll('i');
            stars.forEach((star, index) => {
                if (index < rating) {
                    star.classList.remove('far', 'text-gray-300');
                    star.classList.add('fas', 'text-amber-400');
                } else {
                    star.classList.remove('fas', 'text-amber-400');
                    star.classList.add('far', 'text-gray-300');
                }
            });
            
            // Show eraser button
            const eraserBtn = document.getElementById(`eraser-${recipeId}`);
            if (eraserBtn && !eraserBtn.classList.contains('opacity-100')) {
                eraserBtn.classList.remove('opacity-0', 'pointer-events-none');
                eraserBtn.classList.add('opacity-100');
            }
        }
        
        // Update cards
        this.uiManager.updateRecipeCardRating(recipeId, rating);
        
        // Update recommendations
        this.recommendationEngine.updateRecommendations();
    }

    clearRating(recipeId, event) {
        if (event) {
            event.stopPropagation();
        }
        
        this.userDataManager.clearRating(recipeId);
        
        // Update stars in modal
        const eraserBtn = document.getElementById(`eraser-${recipeId}`);
        if (eraserBtn) {
            eraserBtn.classList.remove('opacity-100');
            eraserBtn.classList.add('opacity-0', 'pointer-events-none');
            const starsContainer = eraserBtn.nextElementSibling;
            if (starsContainer) {
                const stars = starsContainer.querySelectorAll('button');
                stars.forEach(star => {
                    star.innerHTML = '<i class="far fa-star text-gray-300"></i>';
                });
            }
        }
        
        // Update cards
        this.uiManager.updateRecipeCardRating(recipeId, 0);
        
        // Update recommendations
        this.recommendationEngine.updateRecommendations();
    }

    toggleMadeToday(recipeId, event) {
        if (event) {
            event.stopPropagation();
        }
        
        const result = this.userDataManager.toggleMadeToday(recipeId);
        
        // Update button in modal
        const button = event ? event.currentTarget : document.querySelector(`button[onclick*="toggleMadeToday('${recipeId}'"]`);
        
        if (button) {
            const isMobileLayout = window.innerWidth <= CONFIG.BREAKPOINTS.SINGLE_COLUMN;
            
            button.className = `flex items-center ${isMobileLayout ? 'space-x-1' : 'space-x-2'} px-3 py-1.5 rounded-lg transition ${isMobileLayout ? 'text-xs' : 'text-sm'} font-medium ${
                result.madeToday 
                    ? 'bg-amber-600 text-white' + (!isMobileLayout ? ' hover:bg-amber-700' : '')
                    : 'border border-gray-300 text-gray-600 hover:bg-gray-50'
            }`;
            
            button.innerHTML = `
                <i class="fas fa-check"></i>
                <span>Laget (${result.madeCount})</span>
            `;
        }
        
        // Update cards
        this.uiManager.updateRecipeCardCounter(recipeId, result.madeCount);
        
        // Update recommendations
        this.recommendationEngine.updateRecommendations();
    }
}

// ============================================================================
// RECOMMENDATION ENGINE CLASS
// ============================================================================

class RecommendationEngine {
    constructor(recipeDatabase, userDataManager, uiManager) {
        this.recipeDatabase = recipeDatabase;
        this.userDataManager = userDataManager;
        this.uiManager = uiManager;
        this.lastRecommendationUpdate = 0;
        this.recommendationUpdateInterval = 60000; // 1 minute
        this.pendingUpdate = null;
    }

    generateRecommendations() {
        const recommended = document.getElementById('recommendedRecipes');
        
        const recs = this.getRecommendedRecipeIds();
        
        recommended.innerHTML = '';
        recs.forEach(recipeId => {
            const recipe = this.recipeDatabase.findById(recipeId);
            if (recipe) {
                const recipeWithUserData = this.userDataManager.getRecipeWithUserData(recipe);
                const card = this.uiManager.createRecipeCard(recipeWithUserData);
                recommended.appendChild(card);
            }
        });
        
        this.uiManager.setupLazyLoading();
        this.uiManager.setupCardClickHandlers();
        this.lastRecommendationUpdate = Date.now();
    }

    getRecommendedRecipeIds() {
        const recipeIds = this.recipeDatabase.getAllIds();
        
        // Calculate scores for each recipe
        const scoredRecipes = recipeIds.map(id => {
            const userData = this.userDataManager.getRecipeData(id);
            let score = 0;
            
            // Base score
            score = Math.random() * 10;
            
            // High rating bonus (significant boost)
            if (userData.userRating) {
                score += userData.userRating * 3;
            }
            
            // Never viewed bonus
            if (!userData.lastViewed) {
                score += 15;
            }
            
            // Apply time-based penalty for recently viewed
            if (userData.lastViewed) {
                const now = new Date();
                const viewedDate = new Date(userData.lastViewed);
                const hoursSinceView = (now - viewedDate) / (1000 * 60 * 60);
                
                if (hoursSinceView < 24) {
                    // Strong penalty for first 24 hours (exponential decay)
                    const penalty = 30 * Math.exp(-hoursSinceView / 8);
                    score -= penalty;
                } else if (hoursSinceView < 72) {
                    // Medium penalty for 1-3 days
                    const penalty = 10 * (1 - (hoursSinceView - 24) / 48);
                    score -= penalty;
                } else if (hoursSinceView < 168) {
                    // Light penalty for 3-7 days
                    const penalty = 5 * (1 - (hoursSinceView - 72) / 96);
                    score -= penalty;
                } else {
                    // Bonus for old views (nostalgia factor)
                    score += 5;
                }
            }
            
            // Made count influence (slight bonus for frequently made)
            if (userData.madeDates && userData.madeDates.length > 0) {
                score += Math.min(userData.madeDates.length * 0.5, 5);
            }
            
            return { id, score };
        });
        
        // Sort by score and take top 3
        scoredRecipes.sort((a, b) => b.score - a.score);
        return scoredRecipes.slice(0, 3).map(item => item.id);
    }

    updateRecommendations() {
        // Check if recommendations are visible
        const recommendationsSection = document.getElementById('recommendationsSection');
        if (recommendationsSection.style.display === 'none') {
            return;
        }
        
        // Debounce: only update if at least 1 minute has passed
        const now = Date.now();
        const timeSinceLastUpdate = now - this.lastRecommendationUpdate;
        
        // Clear any pending update
        if (this.pendingUpdate) {
            clearTimeout(this.pendingUpdate);
        }
        
        if (timeSinceLastUpdate < this.recommendationUpdateInterval) {
            // Schedule update for later
            const delay = this.recommendationUpdateInterval - timeSinceLastUpdate;
            this.pendingUpdate = setTimeout(() => {
                this.updateRecommendations();
            }, delay);
            return;
        }
        
        const container = document.getElementById('recommendedRecipes');
        const newRecipeIds = this.getRecommendedRecipeIds();
        
        // Check if recommendations actually changed
        const currentCards = Array.from(container.children);
        const currentIds = currentCards.map(c => c.getAttribute('data-recipe-id'));
        const changed = newRecipeIds.length !== currentIds.length || 
                       !newRecipeIds.every((id, i) => id === currentIds[i]);
        
        if (!changed) {
            // Just update the existing cards' data if needed
            this.updateExistingCards(currentCards);
            return;
        }
        
        // Use simple content replacement with crossfade
        this.simpleCrossfadeContent(container, newRecipeIds, currentCards);
        this.lastRecommendationUpdate = now;
    }

    updateExistingCards(cards) {
        cards.forEach(card => {
            const recipeId = card.getAttribute('data-recipe-id');
            const userData = this.userDataManager.getRecipeData(recipeId);
            
            // Update stars
            const stars = card.querySelectorAll('.recipe-stars i');
            stars.forEach((star, index) => {
                if (index < (userData.userRating || 0)) {
                    star.classList.remove('far', 'text-gray-300');
                    star.classList.add('fas', 'text-amber-400');
                } else {
                    star.classList.remove('fas', 'text-amber-400');
                    star.classList.add('far', 'text-gray-300');
                }
            });
            
            // Update counter
            const counter = card.querySelector('.recipe-counter');
            if (counter) {
                const newCount = userData.madeDates ? userData.madeDates.length : 0;
                if (counter.textContent !== newCount.toString()) {
                    counter.textContent = newCount;
                }
            }
        });
    }

    simpleCrossfadeContent(container, newRecipeIds, currentCards) {
        // Ensure we have exactly 3 cards (or as many as we need)
        while (currentCards.length < newRecipeIds.length) {
            const emptyCard = document.createElement('div');
            emptyCard.className = 'bg-white rounded-xl shadow-md overflow-hidden cursor-pointer hover:shadow-xl transition-all duration-300 hover:-translate-y-1';
            container.appendChild(emptyCard);
            currentCards.push(emptyCard);
        }
        
        // Fade out current content
        currentCards.forEach((card, index) => {
            if (index < newRecipeIds.length) {
                card.style.transition = 'opacity 0.3s ease-out';
                card.style.opacity = '0.5';
            } else {
                // Remove extra cards
                card.style.transition = 'opacity 0.3s ease-out';
                card.style.opacity = '0';
                setTimeout(() => card.remove(), 300);
            }
        });
        
        // After fade out, replace content and fade in
        setTimeout(() => {
            newRecipeIds.forEach((recipeId, index) => {
                const recipe = this.recipeDatabase.findById(recipeId);
                if (recipe && currentCards[index]) {
                    const recipeWithUserData = this.userDataManager.getRecipeWithUserData(recipe);
                    const newCard = this.uiManager.createRecipeCard(recipeWithUserData);
                    
                    // Copy the HTML content but keep the same card element
                    const oldCard = currentCards[index];
                    oldCard.innerHTML = newCard.innerHTML;
                    oldCard.setAttribute('data-recipe-id', recipeId);
                    oldCard.setAttribute('data-recipe-click', recipeId);
                    
                    // Fade in
                    requestAnimationFrame(() => {
                        oldCard.style.transition = 'opacity 0.4s ease-out';
                        oldCard.style.opacity = '1';
                    });
                }
            });
            
            // Re-setup handlers after content update
            this.uiManager.setupLazyLoading();
            this.uiManager.setupCardClickHandlers();
        }, 300);
    }

    // Force immediate update (bypasses debouncing)
    forceUpdateRecommendations() {
        if (this.pendingUpdate) {
            clearTimeout(this.pendingUpdate);
            this.pendingUpdate = null;
        }
        this.lastRecommendationUpdate = 0;
        this.updateRecommendations();
    }
}

// ============================================================================
// MAIN APPLICATION CLASS
// ============================================================================

class RecipeApp {
    constructor() {
        // Initialize core components
        this.recipeDatabase = new RecipeDatabase();
        this.userDataManager = new UserDataManager();
        this.uiManager = new UIManager(this.recipeDatabase, this.userDataManager);
        this.recommendationEngine = new RecommendationEngine(
            this.recipeDatabase, 
            this.userDataManager, 
            this.uiManager
        );
        
        // Initialize managers that depend on other components
        this.filterManager = new FilterManager(this.recipeDatabase, this.uiManager);
        this.modalManager = new ModalManager(
            this.recipeDatabase, 
            this.userDataManager, 
            this.uiManager,
            this.recommendationEngine
        );
        
        // Set up the modal callback in UIManager
        this.uiManager.setModalCallback((recipeId) => {
            this.modalManager.showRecipe(recipeId);
        });
        
        // Setup filter event listeners after all components are ready
        this.filterManager.setupEventListeners();
        
        // Initialize the app
        this.init();
    }

    init() {
        // Initial render
        this.filterManager.updateFilterButton();
        this.uiManager.renderRecipes();
        this.recommendationEngine.generateRecommendations();
        this.filterManager.updateRecommendationsVisibility();
        this.uiManager.setupLazyLoading();
    }
}

// ============================================================================
// INITIALIZE APPLICATION
// ============================================================================

// Create global instance for onclick handlers
let recipeApp;

// Initialize when DOM is ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
        recipeApp = new RecipeApp();
    });
} else {
    recipeApp = new RecipeApp();
}
</script>
</body>
</html>