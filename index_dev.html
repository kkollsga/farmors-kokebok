<!DOCTYPE html>
<html lang="no">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
<title>Farmors Oppskrifter</title>
<!-- iOS Web App -->
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="default">
<meta name="apple-mobile-web-app-title" content="Farmors Oppskrifter">

<!-- iOS Home Screen Icon (optional but recommended) -->
<!--  <link rel="apple-touch-icon" href="/icon-180.jpg"> -->

<script src="https://cdn.tailwindcss.com"></script>
<link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;700&family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">
<!-- Font Awesome -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
<style>
    /* ============================================
       BASE STYLES
    ============================================ */
    body { font-family: 'Inter', sans-serif; }
    body.modal-open { overflow: hidden; position: relative; touch-action: none; }
    .font-display { font-family: 'Playfair Display', serif; }
    
    /* ============================================
       SAFE AREA (iOS)
    ============================================ */
    .safe-bottom { padding-bottom: env(safe-area-inset-bottom, 0); }
    .safe-top { padding-top: env(safe-area-inset-top, 0); }
    
    /* ============================================
       SCROLLBAR STYLES
    ============================================ */
    .recipe-scroll::-webkit-scrollbar { width: 6px; }
    .recipe-scroll::-webkit-scrollbar-track { background: #f1f1f1; border-radius: 3px; }
    .recipe-scroll::-webkit-scrollbar-thumb { background: #d4d4d4; border-radius: 3px; }
    .recipe-scroll::-webkit-scrollbar-thumb:hover { background: #a8a8a8; }
    
    /* ============================================
       FILTER DROPDOWN
    ============================================ */
    #filterOptions { overscroll-behavior: contain; -webkit-overflow-scrolling: touch; }
    #filterOptions { background: linear-gradient(white 30%, rgba(255,255,255,0)) center top, linear-gradient(rgba(255,255,255,0), white 70%) center bottom, linear-gradient(white, white) center; background-size: 100% 40px, 100% 40px, 100% 100%; background-attachment: local, local, scroll; background-repeat: no-repeat; }
    
    /* ============================================
       ANIMATIONS
    ============================================ */
    @keyframes tipHighlight { from { transform: translateX(-10px); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
    @keyframes shimmer { 0% { background-position: -1000px 0; } 100% { background-position: 1000px 0; } }
    
    /* ============================================
       CARD TRANSITIONS
    ============================================ */
    [data-recipe-id] { transition: opacity 0.3s ease-out; }
    .recipe-counter { transition: transform 0.2s ease-out; }
    .recipe-stars i { transition: color 0.2s ease-out, transform 0.2s ease-out; }
    
    /* ============================================
       RECOMMENDATIONS CONTAINER
    ============================================ */
    #recommendedRecipes { transition: min-height 0.3s ease-out; position: relative; }
    #recommendedRecipes > div { transition: opacity 0.3s ease-out, transform 0.3s ease-out; }
    
    /* ============================================
       MODAL SCROLLING
    ============================================ */
    #recipeModal .absolute.inset-0 { -webkit-overflow-scrolling: touch; overscroll-behavior: contain; }
    #recipeModal .fixed.top-4.right-4 { transition: transform 0.2s ease-out; }
    #recipeModal .fixed.top-4.right-4:active { transform: scale(0.95); }
    #recipeModal .rounded-t-3xl { box-shadow: 0 -20px 40px rgba(0,0,0,0.3), 0 -10px 20px rgba(0,0,0,0.2); }
    
    /* ============================================
       DESKTOP MODAL
    ============================================ */
    @media (min-width: 901px) {
        #recipeModal .absolute.inset-0 { max-width: 1280px; margin: 0 auto; }
    }
    
    /* ============================================
       iOS SPECIFIC FIXES
    ============================================ */
    @supports (-webkit-touch-callout: none) {
        #recipeModal .absolute.inset-0 { -webkit-overflow-scrolling: touch; }
    }
</style>
</head>
<body class="bg-gradient-to-br from-orange-50 via-amber-50 to-yellow-50 min-h-screen">
<!-- Header -->
<header class="safe-top">
    <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-4">
        <div class="flex justify-between items-center">
            <h1 class="font-display text-3xl text-amber-800">Farmors Oppskrifter</h1>
        </div>
    </div>
</header>

<!-- Search Bar -->
<div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 mt-4">
    <div class="bg-white/95 backdrop-blur rounded-2xl shadow-lg border border-gray-200 p-1.5">
        <div class="relative">
            <i class="fas fa-search absolute left-4 top-1/2 transform -translate-y-1/2 text-gray-400"></i>
            <input type="text" id="searchInput" placeholder="Søk etter oppskrifter eller ingredienser..." 
                   class="modern-input w-full pl-12 pr-4 py-3 bg-gray-50/50 border-0 rounded-xl focus:outline-none focus:bg-white transition-all text-gray-700 placeholder-gray-400">
        </div>
    </div>
</div>

<!-- Filter Bar -->
<div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 mt-4">
    <div class="relative"> <!-- Wrapper for positioning context -->
        <div class="bg-white/95 backdrop-blur rounded-2xl shadow-lg border border-gray-200 p-4">
            <div class="flex items-center gap-3">
                <!-- Filter Button -->
                <button id="filterToggle" onclick="recipeApp.filterManager.toggleFilterMenu()" 
                        class="flex items-center space-x-2 px-4 py-2 rounded-xl transition-all duration-200 text-sm font-medium shrink-0 shadow-sm hover:shadow-md">
                    <i class="fas fa-filter transition-transform duration-200 active:scale-90"></i>
                    <span>Filter</span>
                    <span id="filterCount" class="hidden bg-white/30 text-white text-xs px-1.5 py-0.5 rounded-full font-semibold">0</span>
                </button>
                
                <!-- Filter Pills Container -->
                <div id="filterPillsContainer" class="flex gap-2 flex-1 overflow-hidden transition-[max-width,opacity] duration-300 ease-out whitespace-nowrap">
                    <!-- Filter pills will be inserted here -->
                </div>
            </div>
        </div>
        
        <!-- Clear Filters Button - absolutely positioned -->
        <button id="clearFilters" onclick="recipeApp.filterManager.clearAllFilters()" 
                class="absolute right-0 -bottom-7 text-xs text-gray-500 hover:text-amber-600 transition-all duration-200 opacity-0 pointer-events-none font-medium px-3 py-1 rounded-lg z-10">
            Tøm filter
        </button>
        
        <!-- Filter Dropdown Menu -->
        <div id="filterMenu" class="absolute left-4 top-full mt-2 z-50">
            <div class="bg-white rounded-xl shadow-[0_10px_25px_-5px_rgba(0,0,0,0.1),0_10px_10px_-5px_rgba(0,0,0,0.04)] border border-gray-100 hidden min-w-[280px] max-h-[400px] flex flex-col">
                <div class="text-sm font-semibold text-gray-700 px-4 pt-4 pb-2 border-b border-gray-100 flex-shrink-0">Velg kategorier</div>
                <div id="filterOptions" class="px-4 py-2 overflow-y-auto flex-1 recipe-scroll">
                    <!-- Filter options will be inserted here -->
                </div>
            </div>
        </div>
    </div>
    
    <!-- Sort Selector -->
<div class="flex items-center gap-4 ml-8 mt-4">
    <button data-sort="recommendation" 
            onclick="recipeApp.filterManager.changeSortOrder('recommendation')"
            class="p-2 rounded-lg bg-amber-500 text-white transition-all duration-200"
            title="Anbefalt rekkefølge">
        <i class="fas fa-thumbs-up"></i>
    </button>
    <button data-sort="recipebook" 
            onclick="recipeApp.filterManager.changeSortOrder('recipebook')"
            class="p-2 rounded-lg text-gray-700 hover:text-amber-600 transition-all duration-200"
            title="Oppskriftsbok rekkefølge">
        <i class="fas fa-book"></i>
    </button>
    <button data-sort="alphabetical" 
            onclick="recipeApp.filterManager.changeSortOrder('alphabetical')"
            class="p-2 rounded-lg text-gray-700 hover:text-amber-600 transition-all duration-200"
            title="Alfabetisk">
        <i class="fas fa-sort-alpha-down"></i>
    </button>
    <button data-sort="madecount" 
            onclick="recipeApp.filterManager.changeSortOrder('madecount')"
            class="p-2 rounded-lg text-gray-700 hover:text-amber-600 transition-all duration-200"
            title="Antall ganger laget">
        <i class="fas fa-utensils"></i>
    </button>
    <button data-sort="rating" 
            onclick="recipeApp.filterManager.changeSortOrder('rating')"
            class="p-2 rounded-lg text-gray-700 hover:text-amber-600 transition-all duration-200"
            title="Vurdering">
        <i class="fas fa-star"></i>
    </button>
</div>

<!-- Main Recipe Grid (no header) -->
<div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 mt-2 pb-12 safe-bottom">
    <div id="recipeGrid" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
        <!-- Recipe cards will be inserted here -->
    </div>
</div>

<!-- Recipe Modal -->
<div id="recipeModal" class="fixed inset-0 bg-black bg-opacity-50 hidden z-50">
    <div class="flex items-start justify-center min-h-screen sm:pt-8">
        <div class="bg-red sm:rounded-3xl max-w-5xl w-full sm:h-[92vh] modal-height-mobile flex flex-col overflow-hidden modal-content-mobile">
            <div id="modalContent" class="h-full flex flex-col overflow-y-auto">
                <!-- Recipe content will be inserted here -->
            </div>
        </div>
    </div>
</div>

<script>
// ============================================================================
// CONFIGURATION CONSTANTS
// ============================================================================

const CONFIG = {
    BREAKPOINTS: {
        FULLSCREEN_MODAL: 1000,
        SINGLE_COLUMN: 600
    },
    IMAGE_PATHS: {
        LIST: 'images/low/',
        MODAL: 'images/hi/'
    },
    STYLES: {
        TAGGED_SHADOW: 'shadow-[0_4px_6px_-1px_rgba(180,83,9,0.5),0_2px_4px_-1px_rgba(217,119,6,0.35)]',
        TAGGED_HOVER_SHADOW: 'hover:shadow-[0_10px_15px_-3px_rgba(180,83,9,0.5),0_4px_6px_-2px_rgba(217,119,6,0.35)]',
        DEFAULT_SHADOW: 'shadow-md',
        DEFAULT_HOVER_SHADOW: 'hover:shadow-xl'
    }
};

// ============================================================================
// RECIPE DATABASE CLASS
// ============================================================================

class RecipeDatabase {
    constructor() {
        this.recipes = [
            {"id":"recipe_1755874440324_k3zjgdsow","title":"Aftenbladets Sjokoladekake","servings":"12 porsjoner","provider":"Aftenbladet","reference":"Oppskriftsbok","pageNumber":61,"category":"Lagkaker","meal":"Kake","cuisine":"Norsk","description":"En klassisk norsk sjokoladelagkake slik den ofte ble laget på 60–70-tallet, med lys bunn og fyldig sjokoladekrem. Bunnen er luftig og deles i tre lag, fylt med en rik krem av sukker, melk, smeltet sjokolade og eggeplommer. Pyntes med mandler på toppen.","image":"aftenbladetssjokoladekake.jpg","ingredients":[{"group":"Kakebunn","items":["4 egg","200 g sukker","200 g hvetemel","2 ts bakepulver","100 g smør eller margarin (smeltet)"]},{"group":"Sjokoladekrem","items":["200 g sukker","6 ss melk","1 plate mørk kokesjokolade (ca. 100 g)","2 eggeplommer"]},{"group":"Pynt","items":["Høvlede mandler"]}],"instructions":["Pisk egg og sukker til en luftig eggedosis.","Sikt sammen mel og bakepulver og vend forsiktig inn i eggedosisen.","Rør inn smeltet smør.","Hell røren i en smurt kakeform (ca. 24 cm).","Stek ved 180–190 °C i ca. 35–40 minutter.","Avkjøl kaken helt og del den i tre lag.","Lag kremen: Pisk sukker og melk til hvitt og luftig. Rør inn smeltet kokesjokolade og tilsett eggeplommene.","Fyll kaken lagvis med kremen og dekk toppen.","Pynt med høvlede mandler."],"createdAt":"2025-08-22"},
            {"id":"recipe_1755530008601_5c9sko0oi","title":"Wienerring","servings":"1 stor ring","provider":"Farmor","reference":"Oppskriftsbok","pageNumber":18,"category":"Gjærbakst","meal":"Kaffe","cuisine":"Dansk","description":"Wienerring er en klassisk gjærbakst fylt med en mild krem basert på fløte, vanilje og eggeplomme. Deigen rulles med fyll, formes til en ring og klippes opp slik at fyllet blir synlig under steking. Resultatet er en luftig og dekorativ festkake som passer perfekt på kaffebordet.","image":"wienerring.jpg","ingredients":[{"group":"Deig","items":["250 g hvetemel","50 g sukker","ca. 1 ¼ dl melk (lunken)","1 egg","40 g gjær","100 g smør","1 egg til pensling","Litt hakkede mandler til pynt"]},{"group":"Fyll","items":["1 eggeplomme","1 ½ dl fløte","½ ts vaniljesukker","1 ss potetmel","1 ss sukker"]}],"instructions":["Sikt sammen hvetemel og sukker i en bolle.","Løs opp gjæren i lunken melk og pisk inn egget.","Bland væsken i det tørre og elt deigen til den er smidig. Arbeid inn smøret til slutt. La heve til dobbel størrelse.","Lag fyllet: Pisk sammen fløte, eggeplomme, sukker, potetmel og vaniljesukker. Kok forsiktig opp under omrøring til en tykk krem. Avkjøl.","Kjevle deigen ut til et stort rektangel og fordel fyllet jevnt utover.","Rull deigen sammen fra langsiden til en lang pølse og legg den på et stekebrett med bakepapir.","Form pølsen til en stor ring og klem endene godt sammen.","Klipp skrå snitt med ca. 3 cm mellomrom nesten helt igjennom, og vri hvert stykke litt utover så fyllet synes.","Pensle med egg og dryss over hakkede mandler.","Stek ved 180 °C (varmluft) eller 200 °C (over- og undervarme) i ca. 25–30 minutter til den er gyllenbrun."],"createdAt":"2025-08-18"}
        ];
    }

    findById(recipeId) {
        return this.recipes.find(recipe => recipe.id === recipeId);
    }

    getAllIds() {
        return this.recipes.map(r => r.id);
    }

    getAll() {
        return [...this.recipes];
    }

    getFilters() {
        const categories = new Set();
        const meals = new Set();
        const cuisines = new Set();
        
        this.recipes.forEach(recipe => {
            if (recipe.category) categories.add(recipe.category);
            if (recipe.meal) meals.add(recipe.meal);
            if (recipe.cuisine) cuisines.add(recipe.cuisine);
        });
        
        return {
            categories: Array.from(categories).sort(),
            meals: Array.from(meals).sort(),
            cuisines: Array.from(cuisines).sort()
        };
    }
}

// ============================================================================
// USER DATA MANAGER CLASS
// ============================================================================

class UserDataManager {
    constructor() {
        this.userData = {};
        this.load();
    }

    load() {
        const storedUserData = localStorage.getItem('userData');
        if (storedUserData) {
            this.userData = JSON.parse(storedUserData);
        }
    }

    save() {
        localStorage.setItem('userData', JSON.stringify(this.userData));
    }

    initializeRecipe(recipeId) {
        if (!this.userData[recipeId]) {
            this.userData[recipeId] = {
                userRating: null,
                madeDates: [],
                lastViewed: null,
                viewCount: 0,
                favorite: false,
                tagged: false,
                taggedAt: null
            };
        }
    }

    getRecipeData(recipeId) {
        return this.userData[recipeId] || {
            userRating: null,
            madeDates: [],
            lastViewed: null,
            viewCount: 0,
            favorite: false,
            tagged: false,
            taggedAt: null
        };
    }

    setRating(recipeId, rating) {
        this.initializeRecipe(recipeId);
        this.userData[recipeId].userRating = rating;
        this.save();
    }

    clearRating(recipeId) {
        if (this.userData[recipeId]) {
            this.userData[recipeId].userRating = null;
            this.save();
        }
    }

    toggleTag(recipeId) {
        this.initializeRecipe(recipeId);
        const isTagged = !this.userData[recipeId].tagged;
        this.userData[recipeId].tagged = isTagged;
        this.userData[recipeId].taggedAt = isTagged ? new Date().toISOString() : null;
        this.save();
        return isTagged;
    }

    toggleMadeToday(recipeId) {
        this.initializeRecipe(recipeId);
        const today = new Date().toISOString().split('T')[0];
        const madeDates = this.userData[recipeId].madeDates || [];
        
        const todayIndex = madeDates.indexOf(today);
        if (todayIndex > -1) {
            madeDates.splice(todayIndex, 1);
        } else {
            madeDates.push(today);
        }
        
        this.userData[recipeId].madeDates = madeDates;
        this.save();
        
        return {
            madeToday: madeDates.includes(today),
            madeCount: madeDates.length
        };
    }

    trackView(recipeId) {
        this.initializeRecipe(recipeId);
        this.userData[recipeId].lastViewed = new Date().toISOString();
        this.userData[recipeId].viewCount = (this.userData[recipeId].viewCount || 0) + 1;
        this.save();
    }

    getRecipeWithUserData(recipe) {
        const userInfo = this.getRecipeData(recipe.id);
        return { ...recipe, ...userInfo };
    }
}

// ============================================================================
// FILTER MANAGER CLASS
// ============================================================================

class FilterManager {
    constructor(recipeDatabase, uiManager, recommendationEngine, userDataManager) {
        this.recipeDatabase = recipeDatabase;
        this.uiManager = uiManager;
        this.recommendationEngine = recommendationEngine;
        this.userDataManager = userDataManager;
        this.activeFilters = new Map();
        this.filterMenuOpen = false;
        this.searchQuery = '';
        this.collapsedSections = new Set(['category', 'meal', 'cuisine']);
        this.sortOrder = 'recommendation';
    }


    setupEventListeners() {
        // Search input
        document.getElementById('searchInput').addEventListener('input', (e) => {
            this.searchQuery = e.target.value.toLowerCase();
            this.applyFilters();
        });

        // Close filter menu on outside click
        document.addEventListener('click', (e) => {
            const menu = document.getElementById('filterMenu');
            const toggle = document.getElementById('filterToggle');
            
            if (this.filterMenuOpen && 
                !menu.contains(e.target) && 
                !toggle.contains(e.target)) {
                this.toggleFilterMenu();
            }
        });

        // Prevent body scroll when scrolling inside filter menu
        const filterMenu = document.getElementById('filterMenu');
        
        // Mouse wheel scrolling
        filterMenu.addEventListener('wheel', (e) => {
            const dropdown = filterMenu.querySelector('.absolute');
            if (dropdown && !dropdown.classList.contains('hidden')) {
                const filterOptions = document.getElementById('filterOptions');
                const isScrollable = filterOptions.scrollHeight > filterOptions.clientHeight;
                
                if (isScrollable) {
                    const isAtTop = filterOptions.scrollTop === 0;
                    const isAtBottom = Math.abs(filterOptions.scrollTop + filterOptions.clientHeight - filterOptions.scrollHeight) < 1;
                    
                    if ((e.deltaY < 0 && isAtTop) || (e.deltaY > 0 && isAtBottom)) {
                        e.preventDefault();
                    } else {
                        e.stopPropagation();
                    }
                } else {
                    e.preventDefault();
                }
            }
        }, { passive: false });

        // Touch scrolling for mobile
        let touchStartY = 0;
        
        filterMenu.addEventListener('touchstart', (e) => {
            const dropdown = filterMenu.querySelector('.absolute');
            if (dropdown && !dropdown.classList.contains('hidden')) {
                touchStartY = e.touches[0].clientY;
            }
        }, { passive: true });

        filterMenu.addEventListener('touchmove', (e) => {
            const dropdown = filterMenu.querySelector('.absolute');
            if (dropdown && !dropdown.classList.contains('hidden')) {
                const filterOptions = document.getElementById('filterOptions');
                const touchY = e.touches[0].clientY;
                const deltaY = touchStartY - touchY;
                
                const isAtTop = filterOptions.scrollTop === 0;
                const isAtBottom = Math.abs(filterOptions.scrollTop + filterOptions.clientHeight - filterOptions.scrollHeight) < 1;
                
                if ((deltaY < 0 && isAtTop) || (deltaY > 0 && isAtBottom)) {
                    e.preventDefault();
                }
            }
        }, { passive: false });
    }

    hasActiveSearchOrFilters() {
        return this.searchQuery.length > 0 || this.activeFilters.size > 0;
    }

    changeSortOrder(newOrder) {
        const previousOrder = this.sortOrder;
        this.sortOrder = newOrder;
        
        // Update visual state of sort buttons
        document.querySelectorAll('[data-sort]').forEach(btn => {
            if (btn.getAttribute('data-sort') === newOrder) {
                // Selected button - no hover effect
                btn.classList.remove('text-gray-700', 'hover:text-amber-600');
                btn.classList.add('bg-amber-500', 'text-white');
            } else {
                // Unselected buttons - with hover effect
                btn.classList.remove('bg-amber-500', 'text-white');
                btn.classList.add('text-gray-700', 'hover:text-amber-600');
            }
        });
        
        // If switching back to recommendation from another sort, recalculate scores
        if (newOrder === 'recommendation' && previousOrder !== 'recommendation') {
            this.recommendationEngine.calculateAllScores();
        }
        
        this.applyFilters();
    }

    activateFilter(filterType, filterValue, event) {
        if (event) {
            event.stopPropagation();
        }
        
        const filterKey = `${filterType}:${filterValue}`;
        
        // Close modal if it's open
        const modal = document.getElementById('recipeModal');
        if (!modal.classList.contains('hidden')) {
            recipeApp.modalManager.closeRecipe();  // Keep this as recipeApp since it needs the global reference
        }
        
        // Add filter if not already active
        if (!this.activeFilters.has(filterKey)) {
            this.activeFilters.set(filterKey, true);
            this.renderFilterPills();
            this.updateFilterButton();
            this.applyFilters();
            this.renderFilterOptions();
        }
    }

    toggleFilterSection(section, event) {
        if (event) {
            event.stopPropagation();
        }
        
        if (this.collapsedSections.has(section)) {
            this.collapsedSections.delete(section);
        } else {
            this.collapsedSections.add(section);
        }
        this.renderFilterOptions();
    }

    toggleFilterType(type) {
        if (this.activeFilters.has(type)) {
            this.activeFilters.delete(type);
        } else {
            this.activeFilters.set(type, true);
        }
        this.renderFilterPills();
        this.updateFilterButton();
        this.applyFilters();
        this.renderFilterOptions();
    }

    togglePillActive(type) {
        if (this.activeFilters.has(type)) {
            this.activeFilters.set(type, !this.activeFilters.get(type));
            this.renderFilterPills();
            this.applyFilters();
        }
    }

    removeFilter(type) {
        this.activeFilters.delete(type);
        this.renderFilterPills();
        this.updateFilterButton();
        this.applyFilters();
        this.renderFilterOptions();
    }

    clearAllFilters() {
        this.activeFilters.clear();
        this.renderFilterPills();
        this.updateFilterButton();
        this.applyFilters();
        this.renderFilterOptions();
    }

    toggleFilterMenu() {
        const menu = document.querySelector('#filterMenu > div');
        
        if (!this.filterMenuOpen) {
            this.renderFilterOptions();
            menu.classList.remove('hidden');
            this.filterMenuOpen = true;
        } else {
            menu.classList.add('hidden');
            this.filterMenuOpen = false;
        }
    }

    renderFilterOptions() {
        const container = document.getElementById('filterOptions');
        const filters = this.recipeDatabase.getFilters();
        
        container.innerHTML = '';
        
        // Category filters
        if (filters.categories.length > 0) {
            const isCollapsed = this.collapsedSections.has('category');
            const categorySection = document.createElement('div');
            categorySection.className = 'mb-2';
            
            // Collapsible header
            const categoryHeader = document.createElement('button');
            categoryHeader.className = 'w-full flex items-center justify-between text-xs font-semibold text-gray-500 uppercase tracking-wider px-2 py-2 hover:bg-gray-50 rounded transition-colors';
            categoryHeader.onclick = (e) => {
                e.stopPropagation();
                this.toggleFilterSection('category', e);
            };
            categoryHeader.innerHTML = `
                <span>Kategori</span>
                <i class="fas fa-chevron-${isCollapsed ? 'down' : 'up'} text-gray-400 text-xs transition-transform duration-200"></i>
            `;
            categorySection.appendChild(categoryHeader);
            
            // Collapsible content
            if (!isCollapsed) {
                const categoryContent = document.createElement('div');
                categoryContent.className = 'mt-1';
                
                filters.categories.forEach(category => {
                    const isSelected = this.activeFilters.has(`category:${category}`);
                    const option = document.createElement('label');
                    option.className = 'flex items-center justify-between p-2 hover:bg-amber-50 rounded-lg cursor-pointer transition-colors';
                    option.innerHTML = `
                        <span class="text-sm text-gray-700">${category}</span>
                        <input type="checkbox" 
                            ${isSelected ? 'checked' : ''} 
                            onchange="recipeApp.filterManager.toggleFilterType('category:${category}')"
                            onclick="event.stopPropagation()"
                            class="rounded border-gray-300 text-amber-600 focus:ring-amber-500 cursor-pointer checked:bg-amber-600 checked:border-amber-600">
                    `;
                    categoryContent.appendChild(option);
                });
                
                categorySection.appendChild(categoryContent);
            }
            
            container.appendChild(categorySection);
        }
        
        // Meal filters
        if (filters.meals.length > 0) {
            const isCollapsed = this.collapsedSections.has('meal');
            const mealSection = document.createElement('div');
            mealSection.className = 'mb-2';
            
            // Collapsible header
            const mealHeader = document.createElement('button');
            mealHeader.className = 'w-full flex items-center justify-between text-xs font-semibold text-gray-500 uppercase tracking-wider px-2 py-2 hover:bg-gray-50 rounded transition-colors';
            mealHeader.onclick = (e) => {
                e.stopPropagation();
                this.toggleFilterSection('meal', e);
            };
            mealHeader.innerHTML = `
                <span>Måltid</span>
                <i class="fas fa-chevron-${isCollapsed ? 'down' : 'up'} text-gray-400 text-xs transition-transform duration-200"></i>
            `;
            mealSection.appendChild(mealHeader);
            
            // Collapsible content
            if (!isCollapsed) {
                const mealContent = document.createElement('div');
                mealContent.className = 'mt-1';
                
                filters.meals.forEach(meal => {
                    const isSelected = this.activeFilters.has(`meal:${meal}`);
                    const option = document.createElement('label');
                    option.className = 'flex items-center justify-between p-2 hover:bg-amber-50 rounded-lg cursor-pointer transition-colors';
                    option.innerHTML = `
                        <span class="text-sm text-gray-700">${meal}</span>
                        <input type="checkbox" 
                            ${isSelected ? 'checked' : ''} 
                            onchange="recipeApp.filterManager.toggleFilterType('meal:${meal}')"
                            onclick="event.stopPropagation()"
                            class="rounded border-gray-300 text-amber-600 focus:ring-amber-500 cursor-pointer checked:bg-amber-600 checked:border-amber-600">
                    `;
                    mealContent.appendChild(option);
                });
                
                mealSection.appendChild(mealContent);
            }
            
            container.appendChild(mealSection);
        }
        
        // Cuisine filters
        if (filters.cuisines.length > 0) {
            const isCollapsed = this.collapsedSections.has('cuisine');
            const cuisineSection = document.createElement('div');
            cuisineSection.className = 'mb-2';
            
            // Collapsible header
            const cuisineHeader = document.createElement('button');
            cuisineHeader.className = 'w-full flex items-center justify-between text-xs font-semibold text-gray-500 uppercase tracking-wider px-2 py-2 hover:bg-gray-50 rounded transition-colors';
            cuisineHeader.onclick = (e) => {
                e.stopPropagation();
                this.toggleFilterSection('cuisine', e);
            };
            cuisineHeader.innerHTML = `
                <span>Kjøkken</span>
                <i class="fas fa-chevron-${isCollapsed ? 'down' : 'up'} text-gray-400 text-xs transition-transform duration-200"></i>
            `;
            cuisineSection.appendChild(cuisineHeader);
            
            // Collapsible content
            if (!isCollapsed) {
                const cuisineContent = document.createElement('div');
                cuisineContent.className = 'mt-1';
                
                filters.cuisines.forEach(cuisine => {
                    const isSelected = this.activeFilters.has(`cuisine:${cuisine}`);
                    const option = document.createElement('label');
                    option.className = 'flex items-center justify-between p-2 hover:bg-amber-50 rounded-lg cursor-pointer transition-colors';
                    option.innerHTML = `
                        <span class="text-sm text-gray-700">${cuisine}</span>
                        <input type="checkbox" 
                            ${isSelected ? 'checked' : ''} 
                            onchange="recipeApp.filterManager.toggleFilterType('cuisine:${cuisine}')"
                            onclick="event.stopPropagation()"
                            class="rounded border-gray-300 text-amber-600 focus:ring-amber-500 cursor-pointer checked:bg-amber-600 checked:border-amber-600">
                    `;
                    cuisineContent.appendChild(option);
                });
                
                cuisineSection.appendChild(cuisineContent);
            }
            
            container.appendChild(cuisineSection);
        }
    }

    renderFilterPills() {
        const container = document.getElementById('filterPillsContainer');
        const hasFilters = this.activeFilters.size > 0;
        
        container.innerHTML = '';
        
        // Hide pills if more than 3 filters
        if (this.activeFilters.size > 3) {
            container.style.maxWidth = '0';
            container.style.opacity = '0';
        } else {
            container.style.maxWidth = hasFilters ? '100%' : '0';
            container.style.opacity = hasFilters ? '1' : '0';
            
            let pillCount = 0;
            this.activeFilters.forEach((isActive, filterKey) => {
                if (pillCount >= 3) return;
                
                const [filterType, filterValue] = filterKey.split(':');
                const displayName = filterValue || filterKey;
                
                const pill = document.createElement('div');
                pill.className = `inline-flex items-center gap-1 px-3 py-1.5 rounded-full text-sm transition-all shadow-sm max-w-[150px] ${
                    isActive 
                        ? 'bg-gradient-to-r from-amber-500 to-amber-600 text-white' 
                        : 'bg-gray-200 text-gray-500 opacity-60'
                }`;
                pill.innerHTML = `
                    <span class="cursor-pointer font-medium overflow-hidden text-ellipsis whitespace-nowrap max-w-[120px]" 
                            onclick="recipeApp.filterManager.togglePillActive('${filterKey}')">${displayName}</span>
                    <button onclick="recipeApp.filterManager.removeFilter('${filterKey}')" class="ml-1 hover:opacity-70 flex-shrink-0">
                        <i class="fas fa-times text-xs"></i>
                    </button>
                `;
                container.appendChild(pill);
                pillCount++;
            });
        }
        
        // Update clear button visibility
        const clearBtn = document.getElementById('clearFilters');
        if (hasFilters) {
            clearBtn.classList.remove('opacity-0', 'pointer-events-none');
            clearBtn.classList.add('opacity-100');
        } else {
            clearBtn.classList.add('opacity-0', 'pointer-events-none');
            clearBtn.classList.remove('opacity-100');
        }
    }

    updateFilterButton() {
        const btn = document.getElementById('filterToggle');
        const count = document.getElementById('filterCount');
        const hasFilters = this.activeFilters.size > 0;
        
        btn.className = 'flex items-center space-x-2 px-4 py-2 rounded-xl transition-all text-sm font-medium shrink-0 shadow-sm hover:shadow-md';
        
        if (hasFilters) {
            btn.classList.add('bg-gradient-to-r', 'from-amber-500', 'to-amber-600', 'text-white', 'hover:from-amber-600', 'hover:to-amber-700');
            count.textContent = this.activeFilters.size;
            count.classList.remove('hidden');
            count.classList.add('bg-white/30');
        } else {
            btn.classList.add('bg-white', 'text-gray-700', 'hover:text-amber-600', 'border', 'border-gray-200');
            count.classList.add('hidden');
        }
    }

    applyFilters() {
        let filtered = this.recipeDatabase.getAll();
        
        // Apply category/meal/cuisine filters
        const activeCategoryFilters = [];
        const activeMealFilters = [];
        const activeCuisineFilters = [];
        
        this.activeFilters.forEach((isActive, filterKey) => {
            if (!isActive) return;
            
            const [filterType, filterValue] = filterKey.split(':');
            if (filterType === 'category') {
                activeCategoryFilters.push(filterValue);
            } else if (filterType === 'meal') {
                activeMealFilters.push(filterValue);
            } else if (filterType === 'cuisine') {
                activeCuisineFilters.push(filterValue);
            }
        });
        
        // Filter by category
        if (activeCategoryFilters.length > 0) {
            filtered = filtered.filter(recipe => 
                activeCategoryFilters.includes(recipe.category)
            );
        }
        
        // Filter by meal type
        if (activeMealFilters.length > 0) {
            filtered = filtered.filter(recipe => 
                activeMealFilters.includes(recipe.meal)
            );
        }
        
        // Filter by cuisine type
        if (activeCuisineFilters.length > 0) {
            filtered = filtered.filter(recipe => 
                activeCuisineFilters.includes(recipe.cuisine)
            );
        }
        
        // Apply search filter
        if (this.searchQuery) {
            filtered = filtered.filter(recipe => {
                const titleMatch = recipe.title.toLowerCase().includes(this.searchQuery);
                
                let ingredientMatch = false;
                if (recipe.ingredients) {
                    recipe.ingredients.forEach(item => {
                        if (typeof item === 'string') {
                            if (item.toLowerCase().includes(this.searchQuery)) {
                                ingredientMatch = true;
                            }
                        } else if (item.items) {
                            item.items.forEach(ing => {
                                if (ing.toLowerCase().includes(this.searchQuery)) {
                                    ingredientMatch = true;
                                }
                            });
                        }
                    });
                }
                
                return titleMatch || ingredientMatch;
            });
        }
        
        // Separate tagged and untagged recipes
        const taggedRecipes = [];
        const untaggedRecipes = [];
        
        filtered.forEach(recipe => {
            const userData = this.userDataManager.getRecipeData(recipe.id);
            if (userData.tagged) {
                taggedRecipes.push({
                    recipe,
                    taggedAt: userData.taggedAt
                });
            } else {
                untaggedRecipes.push(recipe);
            }
        });
        
        // Sort tagged recipes by taggedAt (newest first)
        taggedRecipes.sort((a, b) => {
            const dateA = new Date(a.taggedAt || 0);
            const dateB = new Date(b.taggedAt || 0);
            return dateB - dateA;
        });
        
        // Pre-calculate all data needed for sorting to avoid repeated calls
        const recipeDataCache = new Map();
        
        const getRecipeData = (recipe) => {
            if (recipeDataCache.has(recipe.id)) {
                return recipeDataCache.get(recipe.id);
            }
            
            const data = {
                recipe: recipe,
                score: this.recommendationEngine.getRecipeScore(recipe.id),
                rating: this.userDataManager.getRecipeData(recipe.id).userRating || 0,
                madeCount: this.userDataManager.getRecipeData(recipe.id).madeDates?.length || 0,
                pageNumber: recipe.pageNumber || Number.MAX_SAFE_INTEGER,
                title: recipe.title
            };
            
            recipeDataCache.set(recipe.id, data);
            return data;
        };
        
        // Helper comparison functions
        const compareByPageNumber = (dataA, dataB) => {
            if (dataA.pageNumber !== dataB.pageNumber) {
                return dataA.pageNumber - dataB.pageNumber;
            }
            return dataA.recipe.id.localeCompare(dataB.recipe.id);
        };
        
        const compareByRecommendation = (dataA, dataB) => {
            if (dataA.score !== dataB.score) {
                return dataB.score - dataA.score;
            }
            return compareByPageNumber(dataA, dataB);
        };
        
        // Apply sorting to untagged recipes based on current sort order
        const enrichedRecipes = untaggedRecipes.map(recipe => getRecipeData(recipe));
        
        switch(this.sortOrder) {
            case 'recommendation':
                enrichedRecipes.sort(compareByRecommendation);
                break;
            
            case 'alphabetical':
                enrichedRecipes.sort((a, b) => {
                    return a.title.localeCompare(b.title, 'no-NO');
                });
                break;
            
            case 'recipebook':
                enrichedRecipes.sort(compareByPageNumber);
                break;
            
            case 'madecount':
                enrichedRecipes.sort((a, b) => {
                    if (a.madeCount !== b.madeCount) {
                        return b.madeCount - a.madeCount;
                    }
                    return compareByRecommendation(a, b);
                });
                break;
            
            case 'rating':
                enrichedRecipes.sort((a, b) => {
                    if (a.rating !== b.rating) {
                        return b.rating - a.rating;
                    }
                    return compareByRecommendation(a, b);
                });
                break;
        }
        
        // Extract sorted recipes from enriched data
        const sortedUntaggedRecipes = enrichedRecipes.map(data => data.recipe);
        
        // Combine tagged (at top) with untagged
        const finalFiltered = [
            ...taggedRecipes.map(item => item.recipe),
            ...sortedUntaggedRecipes
        ];
        
        const filteredIds = finalFiltered.map(recipe => recipe.id);
        this.uiManager.renderRecipes(filteredIds, false);
    }
}

// ============================================================================
// IMAGE LOADER CLASS
// ============================================================================

class ImageLoader {
    constructor() {
        this.loadingRows = new Set();
        this.loadedImages = new Set();
        this.bufferRows = 20; // Extra rows to load beyond viewport
        this.scrollTimer = null;
        this.resizeTimer = null;
    }
    
    getColumnCount() {
        // Detect from the actual CSS grid
        const grid = document.getElementById('recipeGrid');
        if (!grid || !grid.firstElementChild) return 1;
        
        const gridWidth = grid.offsetWidth;
        const cardWidth = grid.firstElementChild.offsetWidth;
        const gap = 24; // 1.5rem gap from Tailwind gap-6
        
        // Calculate columns accounting for gaps
        const columns = Math.round((gridWidth + gap) / (cardWidth + gap));
        return Math.max(1, columns);
    }
    
    getVisibleRowRange() {
        const grid = document.getElementById('recipeGrid');
        const cards = Array.from(grid.children).filter(card => 
            card.style.display !== 'none'
        );
        
        if (cards.length === 0) return { start: 0, end: 0, totalRows: 0 };
        
        const columnCount = this.getColumnCount();
        const viewportTop = window.scrollY;
        const viewportBottom = viewportTop + window.innerHeight;
        
        let firstVisibleRow = null;
        let lastVisibleRow = null;
        
        // Calculate which rows are visible
        cards.forEach((card, index) => {
            const rect = card.getBoundingClientRect();
            const absoluteTop = rect.top + window.scrollY;
            const absoluteBottom = absoluteTop + rect.height;
            const row = Math.floor(index / columnCount);
            
            // Check if card is in or near viewport
            if (absoluteBottom > viewportTop && absoluteTop < viewportBottom) {
                if (firstVisibleRow === null) firstVisibleRow = row;
                lastVisibleRow = row;
            }
        });
        
        const totalRows = Math.ceil(cards.length / columnCount);
        
        return {
            start: Math.max(0, (firstVisibleRow ?? 0) - this.bufferRows),
            end: Math.min(totalRows - 1, (lastVisibleRow ?? 0) + this.bufferRows),
            totalRows: totalRows
        };
    }
    
    async loadRow(rowIndex) {
        if (this.loadingRows.has(rowIndex)) return;
        
        this.loadingRows.add(rowIndex);
        
        const grid = document.getElementById('recipeGrid');
        const cards = Array.from(grid.children).filter(card => 
            card.style.display !== 'none'
        );
        
        const columnCount = this.getColumnCount();
        const startIdx = rowIndex * columnCount;
        const endIdx = Math.min(startIdx + columnCount, cards.length);
        
        const loadPromises = [];
        
        for (let i = startIdx; i < endIdx; i++) {
            const card = cards[i];
            const img = card.querySelector('img[data-src]');
            
            if (img && !this.loadedImages.has(img)) {
                loadPromises.push(this.loadImage(img));
            }
        }
        
        // Load all images in the row simultaneously
        await Promise.all(loadPromises);
    }
    
    loadImage(img) {
        return new Promise((resolve) => {
            const src = img.getAttribute('data-src');
            if (!src || this.loadedImages.has(img)) {
                resolve();
                return;
            }
            
            this.loadedImages.add(img);
            const tempImg = new Image();
            
            tempImg.onload = () => {
                img.src = src;
                img.classList.add('opacity-100');
                img.removeAttribute('data-src');
                resolve();
            };
            
            tempImg.onerror = () => {
                // Still mark as loaded to prevent retries
                img.removeAttribute('data-src');
                resolve();
            };
            
            tempImg.src = src;
        });
    }
    
    async loadVisibleRows() {
        const { start, end } = this.getVisibleRowRange();
        
        // Load rows sequentially from top to bottom
        for (let row = start; row <= end; row++) {
            await this.loadRow(row);
        }
    }
    
    setupScrollHandler() {
        const handleScroll = () => {
            clearTimeout(this.scrollTimer);
            this.scrollTimer = setTimeout(() => {
                this.loadVisibleRows();
            }, 100);
        };
        
        window.addEventListener('scroll', handleScroll, { passive: true });
        
        // Handle resize events (column count might change)
        window.addEventListener('resize', () => {
            clearTimeout(this.resizeTimer);
            this.resizeTimer = setTimeout(() => {
                // Clear loading state on resize as grid might have changed
                this.loadingRows.clear();
                this.loadVisibleRows();
            }, 250);
        });
    }
    
    reset() {
        // Clear all tracking when filters change
        this.loadedImages.clear();
        this.loadingRows.clear();
    }
}

// ============================================================================
// UI MANAGER CLASS
// ============================================================================

class UIManager {
    constructor(recipeDatabase, userDataManager) {
        this.recipeDatabase = recipeDatabase;
        this.userDataManager = userDataManager;
        this.modalCallback = null; // Will be set later
        this.imageLoader = null; // Initialize as null
    }

    setModalCallback(callback) {
        this.modalCallback = callback;
    }

    formatSource(recipe) {
        let parts = [];
        if (recipe.provider) {
            parts.push(recipe.provider);
        }
        if (recipe.reference) {
            parts.push(recipe.reference);
        }
        if (recipe.pageNumber) {
            parts.push(`s. ${recipe.pageNumber}`);
        }
        return parts.join(' • ');
    }

    renderStars(rating) {
        let stars = '';
        for (let i = 1; i <= 5; i++) {
            if (i <= rating) {
                stars += '<i class="fas fa-star text-amber-400 transition-all duration-200 hover:scale-125"></i>';
            } else {
                stars += '<i class="far fa-star text-gray-300 transition-all duration-200 hover:scale-125"></i>';
            }
        }
        return stars;
    }

    updateRecipeCardTag(recipeId, isTagged) {
        const cards = document.querySelectorAll(`[data-recipe-id="${recipeId}"]`);
        cards.forEach(card => {
            if (isTagged) {
                // Add amber shadow with same size as default
                card.classList.remove(CONFIG.STYLES.DEFAULT_SHADOW, CONFIG.STYLES.DEFAULT_HOVER_SHADOW);
                card.classList.add(...CONFIG.STYLES.TAGGED_SHADOW.split(' '), ...CONFIG.STYLES.TAGGED_HOVER_SHADOW.split(' '));
                
                // Add tag indicator if not present
                const imageContainer = card.querySelector('.h-48');
                if (imageContainer && !imageContainer.querySelector('.fa-tag')) {
                    const tagBadge = document.createElement('span');
                    tagBadge.className = 'absolute top-2 left-2 bg-yellow-600 text-white text-xs font-bold px-2 py-1 rounded-full';
                    tagBadge.innerHTML = '<i class="fas fa-tag"></i>';
                    imageContainer.appendChild(tagBadge);
                }
            } else {
                // Remove amber shadow
                card.classList.remove(...CONFIG.STYLES.TAGGED_SHADOW.split(' '), ...CONFIG.STYLES.TAGGED_HOVER_SHADOW.split(' '));
                card.classList.add(CONFIG.STYLES.DEFAULT_SHADOW, CONFIG.STYLES.DEFAULT_HOVER_SHADOW);
                
                // Remove tag indicator
                const tagBadge = card.querySelector('.fa-tag')?.parentElement;
                if (tagBadge && tagBadge.classList.contains('absolute')) {
                    tagBadge.remove();
                }
            }
        });
    }

    createRecipeCard(recipe) {
        const card = document.createElement('div');
        const isTagged = recipe.tagged || false;
        
        // Darker, more subtle glowing shadow effect (using darker amber/brown tones)
        const shadowClass = isTagged 
            ? `${CONFIG.STYLES.TAGGED_SHADOW} ${CONFIG.STYLES.TAGGED_HOVER_SHADOW}` 
            : `${CONFIG.STYLES.DEFAULT_SHADOW} ${CONFIG.STYLES.DEFAULT_HOVER_SHADOW}`;

        card.className = `bg-white rounded-xl ${shadowClass} overflow-hidden cursor-pointer transition-all duration-300 hover:-translate-y-1`;
        card.setAttribute('data-recipe-id', recipe.id);
        
        // Use data attribute instead of direct onclick
        card.setAttribute('data-recipe-click', recipe.id);
        
        const imageUrl = recipe.image ? CONFIG.IMAGE_PATHS.LIST + recipe.image : null;
        const sourceInfo = this.formatSource(recipe);
        
        card.innerHTML = `
            <div class="h-48 bg-gradient-to-br from-amber-100 to-orange-100 relative overflow-hidden">
                ${recipe.image ? 
                    `<img data-src="${imageUrl}"
                        loading="lazy"
                        alt="${recipe.title}" 
                        class="w-full h-full object-cover opacity-0 transition-opacity duration-300">` : 
                    `<div class="w-full h-full flex items-center justify-center">
                        <span class="text-6xl opacity-30">🍞</span>
                    </div>`}
                ${isTagged ? `<span class="absolute top-2 left-2 bg-yellow-600 text-white text-xs font-bold px-2 py-1 rounded-full">
                    <i class="fas fa-tag"></i>
                </span>` : ''}
                ${recipe.category ? `<span onclick="recipeApp.filterManager.activateFilter('category', '${recipe.category}', event)" 
                    class="absolute top-2 right-2 bg-white/90 backdrop-blur text-xs font-medium px-2 py-1 rounded-full text-amber-700 transition-all duration-200 cursor-pointer hover:scale-105 hover:shadow-lg">
                    ${recipe.category}
                </span>` : ''}
            </div>
            <div class="p-5">
                <h3 class="font-display text-xl text-gray-800 ${sourceInfo ? 'mb-0' : 'mb-2'}">${recipe.title}</h3>
                ${sourceInfo ? `<p class="text-xs text-amber-600 mb-2">${sourceInfo}</p>` : ''}
                ${recipe.description ? `<p class="text-gray-500 text-xs mb-3 overflow-hidden line-clamp-2">${recipe.description}</p>` : ''}
                <div class="flex items-center justify-between gap-2">
                    <div class="recipe-stars flex items-center space-x-1 flex-shrink-0">
                        ${this.renderStars(recipe.userRating || 0)}
                    </div>
                    <div class="flex items-center gap-2 flex-wrap justify-end">
                        ${recipe.cuisine ? 
                            `<span onclick="recipeApp.filterManager.activateFilter('cuisine', '${recipe.cuisine}', event)" 
                                class="inline-block px-2 py-0.5 bg-gray-100 rounded-full text-xs cursor-pointer hover:bg-amber-100 transition-all duration-200 hover:scale-105">
                                ${recipe.cuisine}
                            </span>` : ''}
                        ${recipe.meal ? 
                            `<span onclick="recipeApp.filterManager.activateFilter('meal', '${recipe.meal}', event)" 
                                class="inline-block px-2 py-0.5 bg-gray-100 rounded-full text-xs cursor-pointer hover:bg-amber-100 transition-all duration-200 hover:scale-105">
                                ${recipe.meal}
                            </span>` : ''}
                        <div class="flex items-center ml-2 text-sm text-gray-600">
                            <i class="fas fa-utensils mr-1"></i>
                            <span class="recipe-counter">${recipe.madeDates ? recipe.madeDates.length : 0}</span>
                        </div>
                    </div>
                </div>
            </div>
        `;
        
        return card;
    }

    renderRecipes(recipesToRender = null, forceFullRender = false) {
        const grid = document.getElementById('recipeGrid');
        const recipeIds = recipesToRender || this.recipeDatabase.getAllIds();
        
        // If force full render or grid is empty
        if (forceFullRender || grid.children.length === 0) {
            grid.innerHTML = '';
            recipeIds.forEach(recipeId => {
                const recipe = this.recipeDatabase.findById(recipeId);
                if (recipe) {
                    const recipeWithUserData = this.userDataManager.getRecipeWithUserData(recipe);
                    const card = this.createRecipeCard(recipeWithUserData);
                    grid.appendChild(card);
                }
            });
            this.setupLazyLoading();
            this.setupCardClickHandlers();
            return;
        }
        
        // Smart update: hide/show/reorder existing cards
        const existingCards = new Map();
        Array.from(grid.children).forEach(card => {
            const id = card.getAttribute('data-recipe-id');
            existingCards.set(id, card);
        });
        
        // Hide cards not in the filter
        existingCards.forEach((card, id) => {
            if (!recipeIds.includes(id)) {
                card.style.display = 'none';
            } else {
                card.style.display = '';
            }
        });
        
        // Reorder cards if needed
        const fragment = document.createDocumentFragment();
        recipeIds.forEach(recipeId => {
            if (existingCards.has(recipeId)) {
                const card = existingCards.get(recipeId);
                card.style.display = '';
                fragment.appendChild(card);
            } else {
                // Create new card if it doesn't exist
                const recipe = this.recipeDatabase.findById(recipeId);
                if (recipe) {
                    const recipeWithUserData = this.userDataManager.getRecipeWithUserData(recipe);
                    const card = this.createRecipeCard(recipeWithUserData);
                    fragment.appendChild(card);
                }
            }
        });
        
        grid.innerHTML = '';
        grid.appendChild(fragment);
        
        // Reset image loader and load visible rows
        requestAnimationFrame(() => {
            if (this.imageLoader) {
                this.imageLoader.reset();
                this.imageLoader.loadVisibleRows();
            }
        });
        
        this.setupCardClickHandlers();
    }

    setupCardClickHandlers() {
        // Setup click handlers for all recipe cards
        document.querySelectorAll('[data-recipe-click]').forEach(card => {
            card.onclick = (e) => {
                // Don't trigger if clicking on category filter
                if (e.target.closest('[onclick*="activateFilter"]')) {
                    return;
                }
                const recipeId = card.getAttribute('data-recipe-click');
                if (this.modalCallback) {
                    this.modalCallback(recipeId);
                }
            };
        });
    }

    setupLazyLoading() {
        // Create image loader if it doesn't exist
        if (!this.imageLoader) {
            this.imageLoader = new ImageLoader();
            this.imageLoader.setupScrollHandler();
        }
        
        // Load visible rows immediately
        this.imageLoader.loadVisibleRows();
    }

    updateRecipeCardRating(recipeId, rating) {
        const cards = document.querySelectorAll(`[data-recipe-id="${recipeId}"]`);
        cards.forEach(card => {
            const stars = card.querySelectorAll('.recipe-stars i');
            stars.forEach((star, index) => {
                if (index < rating) {
                    star.classList.remove('far', 'text-gray-300');
                    star.classList.add('fas', 'text-amber-400');
                } else {
                    star.classList.remove('fas', 'text-amber-400');
                    star.classList.add('far', 'text-gray-300');
                }
            });
        });
    }

    updateRecipeCardCounter(recipeId, count) {
        const cards = document.querySelectorAll(`[data-recipe-id="${recipeId}"]`);
        cards.forEach(card => {
            const counterElement = card.querySelector('.recipe-counter');
            if (counterElement && counterElement.textContent !== count.toString()) {
                counterElement.textContent = count;
                // Add a subtle animation
                counterElement.style.transform = 'scale(1.2)';
                setTimeout(() => {
                    counterElement.style.transform = 'scale(1)';
                }, 200);
            }
        });
    }
}

// ============================================================================
// MODAL MANAGER CLASS
// ============================================================================

class ModalManager {
    constructor(recipeDatabase, userDataManager, uiManager, recommendationEngine) {
        this.recipeDatabase = recipeDatabase;
        this.userDataManager = userDataManager;
        this.uiManager = uiManager;
        this.recommendationEngine = recommendationEngine;
        this.scrollPosition = 0;
        this.isFullscreen = false;
        this.currentRecipeId = null;
        this.completedSteps = new Map();
        this.activeStep = null;
        this.setupEventListeners();
    }

    setupEventListeners() {
        // Close modal on outside click (only when not fullscreen)
        document.getElementById('recipeModal').addEventListener('click', (e) => {
            // Check current window width directly instead of relying on stored state
            const currentlyFullscreen = window.innerWidth <= CONFIG.BREAKPOINTS.FULLSCREEN_MODAL;
            if (!currentlyFullscreen) {
                // Use position-based selector for modal wrapper
                const modalWrapper = e.currentTarget.firstElementChild?.firstElementChild;
                if (modalWrapper && !modalWrapper.contains(e.target)) {
                    this.closeRecipe();
                }
            }
        });

        // Handle window resize - IMMEDIATE updates
        window.addEventListener('resize', () => {
            if (this.currentRecipeId) {
                // Immediately update layout and content for smooth transitions
                this.updateModalLayout();
                this.updateModalContent();
            }
        });
        
        // Prevent zoom on iOS rotation
        window.addEventListener('orientationchange', (e) => {
            if (this.currentRecipeId) {
                // Prevent default zoom behavior
                e.preventDefault();
                
                // Force viewport reset
                const viewport = document.querySelector('meta[name="viewport"]');
                viewport.setAttribute('content', 
                    'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover'
                );
                
                // Small delay to ensure proper layout update
                setTimeout(() => {
                    this.updateModalLayout();
                    this.updateModalContent();
                }, 100);
            }
        });
    }

    // Main entry point for showing a recipe
    showRecipe(recipeId) {
        const recipe = this.recipeDatabase.findById(recipeId);
        if (!recipe) return;
        
        this.currentRecipeId = recipeId;
        
        // Clear completed steps and active step for this recipe when opening
        Array.from(this.completedSteps.keys()).forEach(key => {
            if (key.startsWith(recipeId + '-')) {
                this.completedSteps.delete(key);
            }
        });
        if (this.activeStep && this.activeStep.startsWith(recipeId + '-')) {
            this.activeStep = null;
        }
        
        // Track view
        this.userDataManager.trackView(recipeId);
        
        // Lock body scroll - UPDATED APPROACH
        this.scrollPosition = window.pageYOffset;
        document.body.classList.add('modal-open');
        
        // For iOS, prevent scroll on the body
        document.body.style.overflow = 'hidden';
        document.body.style.position = 'relative';
        document.documentElement.style.overflow = 'hidden'; // Also lock html element
        
        // Setup modal layout (fullscreen vs windowed)
        this.setupModalLayout();
        
        // Generate and insert content
        this.updateModalContent();
        
        // Make modal visible
        const modal = document.getElementById('recipeModal');
        modal.classList.remove('hidden');
    }

    toggleTag(recipeId, event) {
        if (event) {
            event.stopPropagation();
        }
        
        const isTagged = this.userDataManager.toggleTag(recipeId);
        
        // Update button in modal
        const button = event ? event.currentTarget : document.querySelector(`button[onclick*="toggleTag('${recipeId}'"]`);
        
        if (button) {
            const isMobileLayout = window.innerWidth <= CONFIG.BREAKPOINTS.SINGLE_COLUMN;
            
            button.className = `flex items-center ${isMobileLayout ? 'space-x-1' : 'space-x-2'} px-3 py-1.5 rounded-lg transition ${isMobileLayout ? 'text-xs' : 'text-sm'} font-medium ${
                isTagged 
                    ? 'bg-yellow-600 text-white' + (!isMobileLayout ? ' hover:bg-yellow-700' : '')
                    : 'border border-gray-300 text-gray-600 hover:bg-gray-50'
            }`;
            
            button.innerHTML = `
                <i class="fas fa-tag"></i>
                ${!isMobileLayout ? '<span>Merk</span>' : ''}
            `;
        }
        
        // Update the card appearance immediately
        this.uiManager.updateRecipeCardTag(recipeId, isTagged);
        
        // Re-apply filters to reorder cards
        const filterManager = recipeApp.filterManager;
        filterManager.applyFilters();
    }

    // Separate function to handle modal container layout
    setupModalLayout() {
        const modal = document.getElementById('recipeModal');
        const flexContainer = modal.firstElementChild;
        const modalWrapper = flexContainer ? flexContainer.firstElementChild : null;
        
        const windowWidth = window.innerWidth;
        this.isFullscreen = windowWidth <= CONFIG.BREAKPOINTS.FULLSCREEN_MODAL;
        
        if (this.isFullscreen) {
            // Fullscreen mode - no backdrop, fill entire viewport
            modal.className = 'fixed inset-0 z-50 bg-gradient-to-br from-amber-100 to-orange-100';  // Add gradient here
            
            // Remove flex container or make it passthrough
            if (flexContainer) {
                flexContainer.className = 'h-full';
            }
            
            // Modal wrapper becomes full viewport
            if (modalWrapper) {
                modalWrapper.className = 'h-full w-full flex flex-col relative';
            }
            
        } else {
            // Desktop modal with backdrop
            modal.className = 'fixed inset-0 bg-black bg-opacity-50 z-50';
            
            // Flex container for centering
            if (flexContainer) {
                flexContainer.className = 'flex items-center justify-center min-h-screen p-4';
            }
            
            // Modal wrapper - Add a base background color
            if (modalWrapper) {
                modalWrapper.className = 'bg-gradient-to-br from-amber-100 to-orange-100 rounded-3xl max-w-5xl w-full h-[92vh] flex flex-col shadow-2xl relative overflow-hidden';
                // Added gradient background to the wrapper itself
            }
        }
    }

    // Update just the modal layout without regenerating content
    updateModalLayout() {
        if (this.currentRecipeId) {
            this.setupModalLayout();
        }
    }

    // Generate hero section (shared between mobile and desktop)
    generateHeroSection(recipe) {
        const imageLowUrl = recipe.image ? CONFIG.IMAGE_PATHS.LIST + recipe.image : null;
        const imageHighUrl = recipe.image ? CONFIG.IMAGE_PATHS.MODAL + recipe.image : null;
        const isMobile = window.innerWidth <= CONFIG.BREAKPOINTS.SINGLE_COLUMN;
        const heroImageHeight = isMobile ? 'h-56' : 'h-80';
        const isFullscreen = window.innerWidth <= CONFIG.BREAKPOINTS.FULLSCREEN_MODAL;
        
        return `
            <!-- Full modal background with rounded corners for desktop -->
            <div class="absolute inset-0 bg-gradient-to-br from-amber-100 to-orange-100 ${!isFullscreen ? 'rounded-2xl' : ''} z-0">
                <!-- Hero image at the top -->
                <div class="absolute inset-x-0 top-0 ${heroImageHeight} ${!isFullscreen ? 'rounded-t-2xl overflow-hidden' : ''}">
                    ${recipe.image ? 
                        `<div class="relative w-full h-full">
                            <!-- Low-res placeholder (loads instantly from cache) -->
                            <img src="${imageLowUrl}" 
                                alt="${recipe.title}" 
                                class="w-full h-full object-cover absolute inset-0 filter blur-sm scale-105">
                            <!-- High-res overlay (loads on top) -->
                            <img src="${imageHighUrl}" 
                                alt="${recipe.title}" 
                                class="w-full h-full object-cover absolute inset-0 opacity-0 transition-opacity duration-500"
                                onload="this.classList.remove('opacity-0'); this.classList.add('opacity-100');">
                        </div>` : 
                        `<div class="w-full h-full flex items-center justify-center">
                            <span class="text-8xl opacity-30">🍞</span>
                        </div>`}
                    ${recipe.category ? 
                        `<span onclick="recipeApp.filterManager.activateFilter('category', '${recipe.category}', event)" 
                            class="absolute top-4 left-4 bg-white/90 backdrop-blur text-xs md:text-sm font-medium px-2 py-1 md:px-3 md:py-1.5 rounded-full text-amber-700 transition-all duration-200 cursor-pointer hover:scale-105 hover:shadow-lg">
                            ${recipe.category}
                        </span>` : ''}
                </div>
            </div>
        `;
    }

    // Generate close button (shared between mobile and desktop)
    generateCloseButton() {
        return `
            <button onclick="recipeApp.modalManager.closeRecipe()" 
                    class="absolute top-4 right-4 z-50 bg-white/90 backdrop-blur rounded-full p-2 md:p-2.5 hover:bg-white shadow-lg transition-transform hover:scale-110">
                <i class="fas fa-times text-gray-600 text-lg md:text-xl"></i>
            </button>
        `;
    }

    // Separate function to handle content generation
    updateModalContent() {
        if (!this.currentRecipeId) return;
        
        const recipe = this.recipeDatabase.findById(this.currentRecipeId);
        if (!recipe) return;
        
        const recipeWithUserData = this.userDataManager.getRecipeWithUserData(recipe);
        const modalWrapper = document.querySelector('#recipeModal > div > div');
        
        if (!modalWrapper) return;
        
        // Store current scroll position before updating
        const scrollContainer = modalWrapper.querySelector('#scrollableContent');
        const currentScrollTop = scrollContainer ? scrollContainer.scrollTop : 0;
        
        // Determine content layout (mobile vs desktop)
        const windowWidth = window.innerWidth;
        const isMobileLayout = windowWidth <= CONFIG.BREAKPOINTS.SINGLE_COLUMN;
        const heroHeight = isMobileLayout ? '14rem' : '20rem'; // h-56 = 14rem, h-80 = 20rem
        const contentMarginTop = isMobileLayout ? 'mt-48' : 'mt-72'; // Slightly less than hero height for overlap
        
        // Build the complete modal content structure
        modalWrapper.innerHTML = `
            ${this.generateHeroSection(recipeWithUserData)}
            ${this.generateCloseButton()}
            <div id="scrollableContent" class="absolute inset-0 overflow-y-auto z-10">
                <div class="${contentMarginTop} min-h-full bg-white rounded-t-3xl shadow-[0_-10px_30px_rgba(0,0,0,0.1)]">
                    ${isMobileLayout ? 
                        this.generateMobileContent(recipeWithUserData) : 
                        this.generateDesktopContent(recipeWithUserData)}
                </div>
            </div>
        `;
        
        // Restore scroll position after content update
        requestAnimationFrame(() => {
            const newScrollContainer = modalWrapper.querySelector('#scrollableContent');
            if (newScrollContainer && currentScrollTop > 0) {
                newScrollContainer.scrollTop = currentScrollTop;
            }
        });
    }

    // Mobile content layout (single column, optimized for touch)
    generateMobileContent(recipe) {
        const sourceInfo = this.uiManager.formatSource(recipe);
        const today = new Date().toISOString().split('T')[0];
        const madeToday = recipe.madeDates && recipe.madeDates.includes(today);
        const madeCount = recipe.madeDates ? recipe.madeDates.length : 0;
        
        return `
            <div class="px-4 py-6">
                <!-- Title and metadata -->
                <div class="mb-4">
                    <h2 class="font-display text-2xl text-gray-800 ${sourceInfo ? 'mb-1' : 'mb-2'}">${recipe.title}</h2>
                    ${sourceInfo ? `<p class="text-xs text-amber-600 mb-2">${sourceInfo}</p>` : ''}
                    ${this.renderTags(recipe)}
                </div>
                
                <!-- Actions -->
                <div class="flex items-center justify-between mb-4">
                    <div class="flex items-center gap-2">
                        <button id="eraser-${recipe.id}" 
                                onclick="recipeApp.modalManager.clearRating('${recipe.id}', event)" 
                                class="text-gray-400 hover:text-gray-600 transition-all duration-200 p-1 ${recipe.userRating ? 'opacity-100' : 'opacity-0 pointer-events-none'}">
                            <i class="fas fa-eraser text-lg"></i>
                        </button>
                        <div class="flex items-center">
                            ${this.renderInteractiveStars(recipe)}
                        </div>
                    </div>
                    <div class="flex items-center gap-2">
                        <button onclick="recipeApp.modalManager.toggleTag('${recipe.id}', event)" 
                                class="flex items-center space-x-1 px-3 py-1.5 rounded-lg transition text-xs font-medium
                                    ${recipe.tagged ? 'bg-yellow-600 text-white' : 'border border-gray-300 text-gray-600 hover:bg-gray-50'}">
                            <i class="fas fa-tag"></i>
                        </button>
                        <button onclick="recipeApp.modalManager.toggleMadeToday('${recipe.id}', event)" 
                                class="flex items-center space-x-1 px-3 py-1.5 rounded-lg transition text-xs font-medium
                                    ${madeToday ? 'bg-amber-600 text-white' : 'border border-gray-300 text-gray-600 hover:bg-gray-50'}">
                            <i class="fas fa-check"></i>
                            <span>Laget (${madeCount})</span>
                        </button>
                    </div>
                </div>
                
                <!-- Description -->
                ${recipe.description ? `
                    <div class="pb-4 mb-6 border-b border-amber-600">
                        <p class="text-gray-700 text-sm leading-relaxed">${recipe.description}</p>
                    </div>
                ` : ''}
                
                <!-- Ingredients -->
                <div class="mb-6 pb-6 border-b border-amber-600">
                    <h3 class="font-display text-xl text-amber-800 mb-3">Ingredienser</h3>
                    ${this.renderIngredients(recipe.ingredients)}
                    <div class="mt-4 flex items-center gap-2 text-amber-600 rounded-lg px-3 py-2 inline-flex">
                        <i class="fas fa-users text-sm"></i>
                        <span class="text-sm font-medium">${recipe.servings}</span>
                    </div>
                </div>
                
                <!-- Instructions -->
                <div class="mb-8">
                    <h3 class="font-display text-xl text-amber-800 mb-3">Slik gjør du</h3>
                    ${this.renderInstructions(recipe.instructions, true)}
                </div>
            </div>
        `;
    }

    // Desktop content layout (two columns, more spacious)
    generateDesktopContent(recipe) {
        const sourceInfo = this.uiManager.formatSource(recipe);
        const today = new Date().toISOString().split('T')[0];
        const madeToday = recipe.madeDates && recipe.madeDates.includes(today);
        const madeCount = recipe.madeDates ? recipe.madeDates.length : 0;
        
        return `
            <div class="px-8 py-8">
                <!-- Header section -->
                <div class="border-b border-gray-100 pb-4 mb-6">
                    <h2 class="font-display text-3xl text-gray-800 ${sourceInfo ? 'mb-1' : 'mb-2'}">${recipe.title}</h2>
                    ${sourceInfo ? `<p class="text-sm text-amber-600 mb-2">${sourceInfo}</p>` : ''}
                    ${this.renderTags(recipe)}
                    
                    <!-- Actions row -->
                    <div class="flex items-center justify-between">
                        <div class="flex items-center gap-4">
                            <!-- Rating -->
                            <div class="flex items-center gap-2">
                                <button id="eraser-${recipe.id}" 
                                        onclick="recipeApp.modalManager.clearRating('${recipe.id}', event)" 
                                        class="text-gray-400 hover:text-gray-600 transition-all duration-200 p-1 ${recipe.userRating ? 'opacity-100' : 'opacity-0 pointer-events-none'}">
                                    <i class="fas fa-eraser text-xl"></i>
                                </button>
                                <div class="flex items-center gap-1">
                                    ${this.renderInteractiveStars(recipe)}
                                </div>
                            </div>
                        </div>
                        
                        <div class="flex items-center gap-2">
                            <!-- Tag button -->
                            <button onclick="recipeApp.modalManager.toggleTag('${recipe.id}', event)" 
                                    class="flex items-center space-x-2 px-4 py-2 rounded-lg transition text-sm font-medium
                                        ${recipe.tagged ? 'bg-yellow-600 text-white hover:bg-yellow-700' : 'border border-gray-300 text-gray-600 hover:bg-gray-50'}">
                                <i class="fas fa-tag"></i>
                                <span>Merk</span>
                            </button>
                            
                            <!-- Made button -->
                            <button onclick="recipeApp.modalManager.toggleMadeToday('${recipe.id}', event)" 
                                    class="flex items-center space-x-2 px-4 py-2 rounded-lg transition text-sm font-medium
                                        ${madeToday ? 'bg-amber-600 text-white hover:bg-amber-700' : 'border border-gray-300 text-gray-600 hover:bg-gray-50'}">
                                <i class="fas fa-check"></i>
                                <span>Laget (${madeCount})</span>
                            </button>
                        </div>
                    </div>
                </div>
                
                <!-- Description -->
                ${recipe.description ? `
                    <div class="pb-6 mb-6 border-b border-amber-600">
                        <p class="text-gray-700 leading-relaxed">${recipe.description}</p>
                    </div>
                ` : ''}
                
                <!-- Two column layout for ingredients and instructions -->
                <div class="grid md:grid-cols-[2fr,3fr] gap-8">
                    <div class="pr-8 border-r border-amber-600">
                        <h3 class="font-display text-xl text-amber-800 mb-4">Ingredienser</h3>
                        ${this.renderIngredients(recipe.ingredients)}
                        <div class="mt-4 flex items-center gap-2 text-amber-600 rounded-lg px-3 py-2 inline-flex">
                            <i class="fas fa-users"></i>
                            <span class="font-medium">${recipe.servings}</span>
                        </div>
                    </div>
                    
                    <div>
                        <h3 class="font-display text-xl text-amber-800 mb-4">Slik gjør du</h3>
                        ${this.renderInstructions(recipe.instructions, false)}
                    </div>
                </div>
            </div>
        `;
    }

    // Helper to render tags (cuisine, meal)
    renderTags(recipe) {
        if (!recipe.cuisine && !recipe.meal) return '';
        
        return `
            <div class="flex gap-2 mb-4">
                ${recipe.cuisine ? 
                    `<span onclick="recipeApp.filterManager.activateFilter('cuisine', '${recipe.cuisine}', event)" 
                        class="inline-block px-2 py-0.5 bg-gray-100 rounded-full text-xs">
                        ${recipe.cuisine} kjøkken
                    </span>` : ''}
                ${recipe.meal ? 
                    `<span onclick="recipeApp.filterManager.activateFilter('meal', '${recipe.meal}', event)" 
                        class="inline-block px-2 py-0.5 bg-gray-100 rounded-full text-xs">
                        ${recipe.meal}
                    </span>` : ''}
            </div>
        `;
    }

    renderIngredients(ingredients) {
        if (!ingredients || ingredients.length === 0) return '';
        
        const hasGroups = ingredients.some(item => typeof item === 'object' && item.group);
        
        if (!hasGroups) {
            return `
                <ul class="space-y-2">
                    ${ingredients.map(ing => `
                        <li class="flex items-start">
                            <span class="text-amber-600 mr-2">•</span>
                            <span class="text-gray-700">${ing}</span>
                        </li>
                    `).join('')}
                </ul>
            `;
        } else {
            return ingredients.map((group, index) => {
                if (typeof group === 'string') {
                    return `
                        <ul class="space-y-2 ${index > 0 ? 'mt-4' : ''}">
                            <li class="flex items-start">
                                <span class="text-amber-600 mr-2">•</span>
                                <span class="text-gray-700">${group}</span>
                            </li>
                        </ul>
                    `;
                }
                
                return `
                    <div class="${index > 0 ? 'mt-5' : ''}">
                        <h4 class="font-semibold text-sm text-amber-700 mb-2">${group.group}:</h4>
                        <ul class="space-y-2">
                            ${group.items.map(ing => `
                                <li class="flex items-start">
                                    <span class="text-amber-600 mr-2">•</span>
                                    <span class="text-gray-700">${ing}</span>
                                </li>
                            `).join('')}
                        </ul>
                    </div>
                `;
            }).join('');
        }
    }

    toggleInstructionStep(recipeId, stepIndex) {
        const key = `${recipeId}-${stepIndex}`;
        const isCompleted = this.completedSteps.get(key) || false;
        const isActive = this.activeStep === key;
        
        const stepElement = document.querySelector(`[data-step="${key}"]`);
        if (!stepElement) return;
        
        // Clear previous active step visually if switching to a new step
        if (this.activeStep && this.activeStep !== key) {
            const prevElement = document.querySelector(`[data-step="${this.activeStep}"]`);
            if (prevElement && !this.completedSteps.get(this.activeStep)) {
                prevElement.parentElement.classList.remove('bg-amber-50', 'border-l-4', 'border-amber-500', 'pl-4', 'pr-0');
                prevElement.parentElement.classList.add('pr-2');
                prevElement.classList.remove('text-black');
                prevElement.classList.add('text-gray-700');
            }
        }
        
        if (!isActive && !isCompleted) {
            // Default → Active
            this.activeStep = key;
            this.completedSteps.delete(key);
            stepElement.classList.remove('line-through', 'text-gray-400');
            stepElement.classList.remove('text-gray-700');
            stepElement.classList.add('text-black');
            stepElement.parentElement.classList.add('bg-amber-50', 'border-l-4', 'border-amber-500', 'pl-4', 'pr-0');
            stepElement.parentElement.classList.remove('pr-2');
        } else if (isActive && !isCompleted) {
            // Active → Completed
            this.completedSteps.set(key, true);
            this.activeStep = null;
            stepElement.classList.add('line-through', 'text-gray-400');
            stepElement.classList.remove('text-black');
            stepElement.parentElement.classList.remove('bg-amber-50', 'border-l-4', 'border-amber-500', 'pl-4', 'pr-0');
            stepElement.parentElement.classList.add('pr-2');
        } else if (isCompleted) {
            // Completed → Active
            this.completedSteps.delete(key);
            this.activeStep = key;
            stepElement.classList.remove('line-through', 'text-gray-400');
            stepElement.classList.add('text-black');
            stepElement.parentElement.classList.add('bg-amber-50', 'border-l-4', 'border-amber-500', 'pl-4', 'pr-0');
            stepElement.parentElement.classList.remove('pr-2');
        }
    }

    // Add these helper methods to the ModalManager class:
    renderTip(tipText, isMobile) {
        const textSizeClass = isMobile ? 'text-sm' : '';
        return `
            <li class="bg-gradient-to-r from-yellow-100 to-yellow-50 border-l-[3px] border-amber-500 rounded-lg ${isMobile ? 'px-3 py-2.5' : 'p-3'} animate-[tipHighlight_0.3s_ease-out]">
                <div class="flex items-start">
                    <span class="text-amber-600 mr-2 flex-shrink-0">
                        <i class="fas fa-lightbulb"></i>
                    </span>
                    <div>
                        <span class="font-semibold text-amber-700 mr-2 text-sm">Tips:</span>
                        <span class="text-gray-700 ${textSizeClass}">${tipText}</span>
                    </div>
                </div>
            </li>
        `;
    }

    renderInstructionStep(instruction, stepNumber, globalIndex, isMobile) {
        const recipeId = this.currentRecipeId;
        const textSizeClass = isMobile ? 'text-sm' : '';
        const stepKey = `${recipeId}-${globalIndex}`;
        const isCompleted = this.completedSteps.get(stepKey) || false;
        const isActive = this.activeStep === stepKey;
        
        return `
            <li class="flex items-start cursor-pointer select-none transition-all duration-200 hover:opacity-80 rounded-lg py-2 pl-2 ${isActive ? 'pr-0' : 'pr-2'} -m-2 
                ${isActive ? 'bg-amber-50 border-l-4 border-amber-500 pl-4' : ''}"
                onclick="recipeApp.modalManager.toggleInstructionStep('${recipeId}', ${globalIndex})">
                <span class="font-semibold text-amber-600 mr-3 flex-shrink-0">${stepNumber}.</span>
                <span data-step="${stepKey}" 
                    class="${textSizeClass} ${isCompleted ? 'line-through text-gray-400' : (isActive ? 'text-black' : 'text-gray-700')} transition-all duration-200">
                    ${instruction}
                </span>
            </li>
        `;
    }

    renderInstructionItem(instruction, stepNumber, globalIndex, isMobile) {
        // Check if it's a tip
        if (typeof instruction === 'string' && (instruction.startsWith('TIP:') || instruction.startsWith('TIPS:'))) {
            const tipText = instruction.replace(/^TIPS?:\s*/i, '');
            return { 
                html: this.renderTip(tipText, isMobile), 
                stepNumber: stepNumber,
                globalIndex: globalIndex 
            };
        }
        
        // Regular instruction step
        return { 
            html: this.renderInstructionStep(instruction, stepNumber, globalIndex, isMobile),
            stepNumber: stepNumber + 1,
            globalIndex: globalIndex + 1
        };
    }

    renderInstructions(instructions, isMobile = false) {
        if (!instructions || instructions.length === 0) return '';
        
        let stepNumber = 1;
        let globalIndex = 0;
        
        // Check if we have grouped instructions
        const hasGroups = instructions.some(item => typeof item === 'object' && item.group);
        
        // Simple flat instructions
        if (!hasGroups) {
            const items = [];
            instructions.forEach(inst => {
                const result = this.renderInstructionItem(inst, stepNumber, globalIndex, isMobile);
                items.push(result.html);
                stepNumber = result.stepNumber;
                globalIndex = result.globalIndex;
            });
            
            return `<ol class="space-y-3">${items.join('')}</ol>`;
        }
        
        // Grouped instructions
        const sections = [];
        
        instructions.forEach((item, index) => {
            if (typeof item === 'string') {
                // Single instruction outside a group
                const result = this.renderInstructionItem(item, stepNumber, globalIndex, isMobile);
                sections.push(`<ol class="space-y-3 ${index > 0 ? 'mt-3' : ''}">${result.html}</ol>`);
                stepNumber = result.stepNumber;
                globalIndex = result.globalIndex;
            } else if (item.group && item.steps) {
                // Group of instructions with indent and tighter spacing
                const groupItems = [];
                item.steps.forEach(inst => {
                    const result = this.renderInstructionItem(inst, stepNumber, globalIndex, isMobile);
                    groupItems.push(result.html);
                    stepNumber = result.stepNumber;
                    globalIndex = result.globalIndex;
                });
                
                sections.push(`
                    <div class="${index > 0 ? 'mt-4' : ''}">
                        <h4 class="font-semibold text-sm text-amber-700 mb-2">${item.group}:</h4>
                        <ol class="space-y-2 ${isMobile ? 'pl-3' : 'pl-4'}">
                            ${groupItems.join('')}
                        </ol>
                    </div>
                `);
            }
        });
        
        return sections.join('');
    }

    renderInteractiveStars(recipe) {
        let stars = '';
        const userRating = recipe.userRating || 0;
        for (let i = 1; i <= 5; i++) {
            const filled = i <= userRating;
            stars += `<button onclick="recipeApp.modalManager.rateRecipe('${recipe.id}', ${i}, event)" 
                            class="text-2xl transition-all duration-200 hover:scale-125 hover:text-amber-500">
                <i class="${filled ? 'fas' : 'far'} fa-star ${filled ? 'text-amber-400' : 'text-gray-300'}"></i>
            </button>`;
        }
        return stars;
    }

    closeRecipe() {
        const modal = document.getElementById('recipeModal');
        
        // Clear current recipe
        this.currentRecipeId = null;
        this.isFullscreen = false;
        
        // Hide modal
        modal.classList.add('hidden');
        
        // Restore body scroll - UPDATED APPROACH
        document.body.classList.remove('modal-open');
        document.body.style.overflow = '';
        document.body.style.position = '';
        document.documentElement.style.overflow = ''; // Restore html element
        // Remove the line that resets body.style.top
        // document.body.style.top = ''; // REMOVE THIS
        window.scrollTo(0, this.scrollPosition);
        
        // Reset modal classes to default state
        this.resetModalToDefault();
    }

    // Reset modal to default state (for next opening)
    resetModalToDefault() {
        const modal = document.getElementById('recipeModal');
        const flexContainer = modal.firstElementChild;
        const modalWrapper = flexContainer ? flexContainer.firstElementChild : null;
        
        // Reset to default classes
        modal.className = 'fixed inset-0 bg-black bg-opacity-50 hidden z-50';
        
        if (flexContainer) {
            flexContainer.className = 'flex items-start justify-center min-h-screen sm:pt-8';
        }
        
        if (modalWrapper) {
            // Removed bg-white from here too
            modalWrapper.className = 'sm:rounded-2xl max-w-5xl w-full sm:h-[92vh] modal-height-mobile flex flex-col modal-content-mobile';
            modalWrapper.innerHTML = '';
        }
    }

    rateRecipe(recipeId, rating, event) {
        if (event) {
            event.stopPropagation();
        }
        
        this.userDataManager.setRating(recipeId, rating);
        
        // Update stars in modal
        const button = event ? event.currentTarget : null;
        if (button && button.parentElement) {
            const stars = button.parentElement.querySelectorAll('i');
            stars.forEach((star, index) => {
                if (index < rating) {
                    star.classList.remove('far', 'text-gray-300');
                    star.classList.add('fas', 'text-amber-400');
                } else {
                    star.classList.remove('fas', 'text-amber-400');
                    star.classList.add('far', 'text-gray-300');
                }
            });
            
            // Show eraser button
            const eraserBtn = document.getElementById(`eraser-${recipeId}`);
            if (eraserBtn && !eraserBtn.classList.contains('opacity-100')) {
                eraserBtn.classList.remove('opacity-0', 'pointer-events-none');
                eraserBtn.classList.add('opacity-100');
            }
        }
        
        // Update cards
        this.uiManager.updateRecipeCardRating(recipeId, rating);
        
        // Update recommendation score for this recipe
        this.recommendationEngine.updateScoreForRecipe(recipeId);
        
        // Re-sort if we're in recommendation or rating mode
        const filterManager = recipeApp.filterManager;
        if (filterManager.sortOrder === 'recommendation' || filterManager.sortOrder === 'rating') {
            filterManager.applyFilters();
        }
    }

    clearRating(recipeId, event) {
        if (event) {
            event.stopPropagation();
        }
        
        this.userDataManager.clearRating(recipeId);
        
        // Update stars in modal
        const eraserBtn = document.getElementById(`eraser-${recipeId}`);
        if (eraserBtn) {
            eraserBtn.classList.remove('opacity-100');
            eraserBtn.classList.add('opacity-0', 'pointer-events-none');
            const starsContainer = eraserBtn.nextElementSibling;
            if (starsContainer) {
                const stars = starsContainer.querySelectorAll('button');
                stars.forEach(star => {
                    star.innerHTML = '<i class="far fa-star text-gray-300"></i>';
                });
            }
        }
        
        // Update cards
        this.uiManager.updateRecipeCardRating(recipeId, 0);
        
        // Update recommendation score for this recipe
        this.recommendationEngine.updateScoreForRecipe(recipeId);
        
        // Re-sort if we're in recommendation or rating mode
        const filterManager = recipeApp.filterManager;
        if (filterManager.sortOrder === 'recommendation' || filterManager.sortOrder === 'rating') {
            filterManager.applyFilters();
        }
    }

    toggleMadeToday(recipeId, event) {
        if (event) {
            event.stopPropagation();
        }
        
        const result = this.userDataManager.toggleMadeToday(recipeId);
        
        // Update button in modal
        const button = event ? event.currentTarget : document.querySelector(`button[onclick*="toggleMadeToday('${recipeId}'"]`);
        
        if (button) {
            const isMobileLayout = window.innerWidth <= CONFIG.BREAKPOINTS.SINGLE_COLUMN;
            
            button.className = `flex items-center ${isMobileLayout ? 'space-x-1' : 'space-x-2'} px-3 py-1.5 rounded-lg transition ${isMobileLayout ? 'text-xs' : 'text-sm'} font-medium ${
                result.madeToday 
                    ? 'bg-amber-600 text-white' + (!isMobileLayout ? ' hover:bg-amber-700' : '')
                    : 'border border-gray-300 text-gray-600 hover:bg-gray-50'
            }`;
            
            button.innerHTML = `
                <i class="fas fa-check"></i>
                <span>Laget (${result.madeCount})</span>
            `;
        }
        
        // Update cards
        this.uiManager.updateRecipeCardCounter(recipeId, result.madeCount);
        
        // Update recommendation score for this recipe
        this.recommendationEngine.updateScoreForRecipe(recipeId);
        
        // Re-sort if we're in recommendation or made count mode
        const filterManager = recipeApp.filterManager;
        if (filterManager.sortOrder === 'recommendation' || filterManager.sortOrder === 'madecount') {
            filterManager.applyFilters();
        }
    }
}

// ============================================================================
// RECOMMENDATION ENGINE CLASS
// ============================================================================

class RecommendationEngine {
    constructor(recipeDatabase, userDataManager, uiManager) {
        this.recipeDatabase = recipeDatabase;
        this.userDataManager = userDataManager;
        this.uiManager = uiManager;
        this.recipeScores = new Map();
    }

    calculateAllScores() {
        // Clear existing scores to force fresh calculation
        this.recipeScores.clear();
        
        const recipeIds = this.recipeDatabase.getAllIds();
        
        recipeIds.forEach(id => {
            const score = this.calculateRecipeScore(id);
            this.recipeScores.set(id, score);
        });
    }

    calculateRecipeScore(recipeId) {
        const recipe = this.recipeDatabase.findById(recipeId);
        const userData = this.userDataManager.getRecipeData(recipeId);
        
        // Weight configuration - adjust these to change importance
        const WEIGHTS = {
            BASE: 20,                 // Base score everyone starts with
            USER_RATING: 10,          // 0-50 points (rating * multiplier)
            NEVER_VIEWED: 30,         // 30 points bonus
            MADE_COUNT: 5,            // 0-10 points based on how often made
            NOSTALGIA_BONUS: 10,      // Bonus for old views
            
            // Recency multipliers (applied to base score portion)
            RECENCY_TODAY: 0.1,       // Viewed today
            RECENCY_RECENT: 0.3,      // 1-3 days ago
            RECENCY_WEEK: 0.6,        // 3-7 days ago
            RECENCY_NORMAL: 1.0,      // 7-30 days ago
            
            // Category multipliers (applied to total score)
            JULEKAKER_CHRISTMAS: 3.0,    // Nov-Dec multiplier
            JULEKAKER_JANUARY: 1.5,      // January multiplier
            JULEKAKER_OFF_SEASON: 0.05,  // Feb-Oct multiplier  
            SLAKTEVEILEDNING: 0.01,      // Year-round penalty
        };
        
        // Start with base score
        let score = WEIGHTS.BASE;
        
        // Add user rating bonus (0 to 50 based on 1-5 star rating)
        if (userData.userRating) {
            score += userData.userRating * WEIGHTS.USER_RATING;
        }
        
        // Add discovery bonus - never viewed recipes get a boost
        if (!userData.lastViewed) {
            score += WEIGHTS.NEVER_VIEWED;
        }
        
        // Apply recency multiplier (reduces score for recent views)
        let recencyMultiplier = WEIGHTS.RECENCY_NORMAL;
        
        if (userData.lastViewed) {
            const now = new Date();
            const viewedDate = new Date(userData.lastViewed);
            const daysSinceView = (now - viewedDate) / (1000 * 60 * 60 * 24);
            
            if (daysSinceView < 1) {
                // Viewed today - heavy reduction
                recencyMultiplier = WEIGHTS.RECENCY_TODAY;
            } else if (daysSinceView < 3) {
                // 1-3 days ago - moderate reduction
                recencyMultiplier = WEIGHTS.RECENCY_RECENT;
            } else if (daysSinceView < 7) {
                // 3-7 days ago - light reduction
                recencyMultiplier = WEIGHTS.RECENCY_WEEK;
            } else if (daysSinceView > 30) {
                // Over a month ago - add nostalgia bonus
                score += WEIGHTS.NOSTALGIA_BONUS;
            }
        }
        
        // Apply recency multiplier
        score *= recencyMultiplier;
        
        // Add popularity bonus - frequently made recipes
        if (userData.madeDates && userData.madeDates.length > 0) {
            // Cap at 10 points max (if made 10+ times)
            const madeBonus = Math.min(userData.madeDates.length, 10) * (WEIGHTS.MADE_COUNT / 10);
            score += madeBonus;
        }
        
        // Apply category-based multipliers
        if (recipe) {
            // Christmas cakes - seasonal adjustment
            if (recipe.category === 'Julekaker') {
                const now = new Date();
                const month = now.getMonth(); // 0 = January, 11 = December
                
                if (month === 10 || month === 11) {
                    // November & December - prime season
                    score *= WEIGHTS.JULEKAKER_CHRISTMAS;
                } else if (month === 0) {
                    // January - still acceptable
                    score *= WEIGHTS.JULEKAKER_JANUARY;
                } else {
                    // February through October - heavily penalized
                    score *= WEIGHTS.JULEKAKER_OFF_SEASON;
                }
            }
            
            // Preserves - always deprioritized
            if (recipe.category === 'Slakteveiledning') {
                score *= WEIGHTS.SLAKTEVEILEDNING;
            }
        }
        
        // Ensure minimum score of 0
        return Math.max(score, 0);
    }

    getRecipeScore(recipeId) {
        // Return cached score if available
        if (this.recipeScores.has(recipeId)) {
            return this.recipeScores.get(recipeId);
        }
        
        // Calculate and cache the score
        const score = this.calculateRecipeScore(recipeId);
        this.recipeScores.set(recipeId, score);
        return score;
    }

    updateScoreForRecipe(recipeId) {
        // Recalculate score for a specific recipe (e.g., after rating/making it)
        const score = this.calculateRecipeScore(recipeId);
        this.recipeScores.set(recipeId, score);
    }
}

// ============================================================================
// MAIN APPLICATION CLASS
// ============================================================================

class RecipeApp {
    constructor() {
        // Remove this line: window.recipeApp = this;
        
        // Initialize core components
        this.recipeDatabase = new RecipeDatabase();
        this.userDataManager = new UserDataManager();
        this.uiManager = new UIManager(this.recipeDatabase, this.userDataManager);
        this.recommendationEngine = new RecommendationEngine(
            this.recipeDatabase, 
            this.userDataManager, 
            this.uiManager
        );
        
        // Initialize managers that depend on other components
        this.filterManager = new FilterManager(
            this.recipeDatabase, 
            this.uiManager,
            this.recommendationEngine,
            this.userDataManager
        );
        this.modalManager = new ModalManager(
            this.recipeDatabase, 
            this.userDataManager, 
            this.uiManager,
            this.recommendationEngine
        );
        
        // Set up the modal callback in UIManager
        this.uiManager.setModalCallback((recipeId) => {
            this.modalManager.showRecipe(recipeId);
        });
        
        // Setup filter event listeners after all components are ready
        this.filterManager.setupEventListeners();
        
        // Initialize the app
        this.init();
    }

    init() {
        // Calculate initial recommendation scores
        this.recommendationEngine.calculateAllScores();
        
        // Initial render with recommendation sorting
        this.filterManager.updateFilterButton();
        this.filterManager.applyFilters(); // This will now sort by recommendation by default
        this.uiManager.setupLazyLoading();
    }
}

// ============================================================================
// INITIALIZE APPLICATION
// ============================================================================

// Create global instance for onclick handlers
let recipeApp;

// Initialize when DOM is ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
        recipeApp = new RecipeApp();
    });
} else {
    recipeApp = new RecipeApp();
}
</script>
</body>
</html>