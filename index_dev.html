<!DOCTYPE html>
<html lang="no">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
<title>Farmors Oppskrifter</title>
<!-- iOS Web App -->
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="default">
<meta name="apple-mobile-web-app-title" content="Farmors Oppskrifter">

<!-- iOS Home Screen Icon (optional but recommended) -->
<!--  <link rel="apple-touch-icon" href="/icon-180.jpg"> -->

<script src="https://cdn.tailwindcss.com"></script>
<link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;700&family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">
<!-- Font Awesome -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
<style>
    /* ============================================
       BASE STYLES
    ============================================ */
    body { font-family: 'Inter', sans-serif; }
    body.modal-open { overflow: hidden; position: relative; touch-action: none; }
    .font-display { font-family: 'Playfair Display', serif; }
    
    /* ============================================
       SAFE AREA (iOS)
    ============================================ */
    .safe-bottom { padding-bottom: env(safe-area-inset-bottom, 0); }
    .safe-top { padding-top: env(safe-area-inset-top, 0); }
    
    /* ============================================
       SCROLLBAR STYLES
    ============================================ */
    .recipe-scroll::-webkit-scrollbar { width: 6px; }
    .recipe-scroll::-webkit-scrollbar-track { background: #f1f1f1; border-radius: 3px; }
    .recipe-scroll::-webkit-scrollbar-thumb { background: #d4d4d4; border-radius: 3px; }
    .recipe-scroll::-webkit-scrollbar-thumb:hover { background: #a8a8a8; }
    
    /* ============================================
       FILTER DROPDOWN
    ============================================ */
    #filterOptions { overscroll-behavior: contain; -webkit-overflow-scrolling: touch; }
    #filterOptions { background: linear-gradient(white 30%, rgba(255,255,255,0)) center top, linear-gradient(rgba(255,255,255,0), white 70%) center bottom, linear-gradient(white, white) center; background-size: 100% 40px, 100% 40px, 100% 100%; background-attachment: local, local, scroll; background-repeat: no-repeat; }
    
    /* ============================================
       ANIMATIONS
    ============================================ */
    @keyframes tipHighlight { from { transform: translateX(-10px); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
    @keyframes shimmer { 0% { background-position: -1000px 0; } 100% { background-position: 1000px 0; } }
    
    /* ============================================
       CARD TRANSITIONS
    ============================================ */
    [data-recipe-id] { transition: opacity 0.3s ease-out; }
    .recipe-counter { transition: transform 0.2s ease-out; }
    .recipe-stars i { transition: color 0.2s ease-out, transform 0.2s ease-out; }
    
    /* ============================================
       RECOMMENDATIONS CONTAINER
    ============================================ */
    #recommendedRecipes { transition: min-height 0.3s ease-out; position: relative; }
    #recommendedRecipes > div { transition: opacity 0.3s ease-out, transform 0.3s ease-out; }
    
    /* ============================================
       MODAL SCROLLING
    ============================================ */
    #recipeModal .absolute.inset-0 { -webkit-overflow-scrolling: touch; overscroll-behavior: contain; }
    #recipeModal .fixed.top-4.right-4 { transition: transform 0.2s ease-out; }
    #recipeModal .fixed.top-4.right-4:active { transform: scale(0.95); }
    #recipeModal .rounded-t-3xl { box-shadow: 0 -20px 40px rgba(0,0,0,0.3), 0 -10px 20px rgba(0,0,0,0.2); }
    
    /* ============================================
       DESKTOP MODAL
    ============================================ */
    @media (min-width: 901px) {
        #recipeModal .absolute.inset-0 { max-width: 1280px; margin: 0 auto; }
    }
    
    /* ============================================
       iOS SPECIFIC FIXES
    ============================================ */
    @supports (-webkit-touch-callout: none) {
        #recipeModal .absolute.inset-0 { -webkit-overflow-scrolling: touch; }
    }
</style>
</head>
<body class="bg-gradient-to-br from-orange-50 via-amber-50 to-yellow-50 min-h-screen">
<!-- Header -->
<header class="safe-top">
    <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-4">
        <div class="flex justify-between items-center">
            <h1 class="font-display text-3xl text-amber-800">Farmors Oppskrifter</h1>
        </div>
    </div>
</header>

<!-- Search Bar -->
<div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 mt-4">
    <div class="bg-white/95 backdrop-blur rounded-2xl shadow-lg border border-gray-200 p-1.5">
        <div class="relative">
            <i class="fas fa-search absolute left-4 top-1/2 transform -translate-y-1/2 text-gray-400"></i>
            <input type="text" id="searchInput" placeholder="Søk etter oppskrifter eller ingredienser..." 
                   class="modern-input w-full pl-12 pr-4 py-3 bg-gray-50/50 border-0 rounded-xl focus:outline-none focus:bg-white transition-all text-gray-700 placeholder-gray-400">
        </div>
    </div>
</div>

<!-- Filter Bar -->
<div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 mt-4">
    <div class="relative">
        <div class="bg-white/95 backdrop-blur rounded-2xl shadow-lg border border-gray-200 p-4">
            <div class="flex items-center gap-3">
                <!-- Filter Button -->
                <button id="filterToggle" onclick="recipeApp.filterManager.toggleFilterMenu()" 
                        class="flex items-center space-x-2 px-4 py-2 rounded-xl transition-all duration-200 text-sm font-medium shrink-0 shadow-sm hover:shadow-md">
                    <i class="fas fa-filter transition-transform duration-200 active:scale-90"></i>
                    <span>Filter</span>
                    <span id="filterCount" class="hidden bg-white/30 text-white text-xs px-1.5 py-0.5 rounded-full font-semibold">0</span>
                </button>
                
                <!-- Filter Pills Container -->
                <div id="filterPillsContainer" class="flex gap-2 flex-1 overflow-hidden transition-[max-width,opacity] duration-300 ease-out whitespace-nowrap">
                    <!-- Filter pills will be inserted here -->
                </div>
            </div>
        </div>
        
        <!-- Buttons Container - stays on right with flex -->
        <div class="absolute -bottom-7 inset-x-0 flex justify-end gap-2">
            <!-- Copy URL Button -->
            <button id="copyURLButton" onclick="recipeApp.urlManager.copyToClipboard(recipeApp.urlManager.getShareableURL(), this)" 
                    class="text-xs text-gray-500 hover:text-amber-600 transition-all duration-200 font-medium px-3 py-1 rounded-lg">
                <i class="fas fa-copy sm:mr-1"></i>
                <span class="hidden sm:inline">Kopier URL</span>
            </button>
            
            <!-- Clear Filters Button -->
            <button id="clearFilters" onclick="recipeApp.filterManager.clearAllFilters()" 
                    class="hidden text-xs text-gray-500 hover:text-amber-600 transition-all duration-200 font-medium px-3 py-1 rounded-lg">
                <i class="fas fa-times sm:mr-1"></i>
                <span class="hidden sm:inline">Tøm filter</span>
            </button>
        </div>
        
        <!-- Filter Dropdown Menu -->
        <div id="filterMenu" class="absolute left-4 top-full mt-2 z-50">
            <div class="bg-white rounded-xl shadow-[0_10px_25px_-5px_rgba(0,0,0,0.1),0_10px_10px_-5px_rgba(0,0,0,0.04)] border border-gray-100 hidden min-w-[280px] max-h-[400px] flex flex-col">
                <div class="text-sm font-semibold text-gray-700 px-4 pt-4 pb-2 border-b border-gray-100 flex-shrink-0">Velg kategorier</div>
                <div id="filterOptions" class="px-4 py-2 overflow-y-auto flex-1 recipe-scroll">
                    <!-- Filter options will be inserted here -->
                </div>
            </div>
        </div>
    </div>
    
    <!-- Sort Selector -->
    <div class="flex items-center gap-4 ml-8 mt-4">
        <button data-sort="recommendation" 
                onclick="recipeApp.filterManager.changeSortOrder('recommendation')"
                class="p-2 rounded-lg bg-amber-500 text-white transition-all duration-200"
                title="Anbefalt rekkefølge">
            <i class="fas fa-thumbs-up"></i>
        </button>
        <button data-sort="recipebook" 
                onclick="recipeApp.filterManager.changeSortOrder('recipebook')"
                class="p-2 rounded-lg text-gray-700 hover:text-amber-600 transition-all duration-200"
                title="Oppskriftsbok rekkefølge">
            <i class="fas fa-book"></i>
        </button>
        <button data-sort="alphabetical" 
                onclick="recipeApp.filterManager.changeSortOrder('alphabetical')"
                class="p-2 rounded-lg text-gray-700 hover:text-amber-600 transition-all duration-200"
                title="Alfabetisk">
            <i class="fas fa-sort-alpha-down"></i>
        </button>
        <button data-sort="madecount" 
                onclick="recipeApp.filterManager.changeSortOrder('madecount')"
                class="p-2 rounded-lg text-gray-700 hover:text-amber-600 transition-all duration-200"
                title="Antall ganger laget">
            <i class="fas fa-utensils"></i>
        </button>
        <button data-sort="rating" 
                onclick="recipeApp.filterManager.changeSortOrder('rating')"
                class="p-2 rounded-lg text-gray-700 hover:text-amber-600 transition-all duration-200"
                title="Vurdering">
            <i class="fas fa-star"></i>
        </button>
    </div>
</div>

<!-- Main Recipe Grid (no header) -->
<div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 mt-2 pb-12 safe-bottom">
    <div id="recipeGrid" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
        <!-- Recipe cards will be inserted here -->
    </div>
</div>

<!-- Recipe Modal -->
<div id="recipeModal" class="fixed inset-0 bg-black bg-opacity-50 hidden z-50">
    <div class="flex items-start justify-center min-h-screen sm:pt-8">
        <div class="bg-red sm:rounded-3xl max-w-5xl w-full sm:h-[92vh] modal-height-mobile flex flex-col overflow-hidden modal-content-mobile">
            <div id="modalContent" class="h-full flex flex-col overflow-y-auto">
                <!-- Recipe content will be inserted here -->
            </div>
        </div>
    </div>
</div>

<script>
// ============================================================================
// CONFIGURATION CONSTANTS
// ============================================================================

const CONFIG = {
    BREAKPOINTS: {
        FULLSCREEN_MODAL: 1000,
        SINGLE_COLUMN: 600
    },
    IMAGE_PATHS: {
        LIST: 'images/low/',
        MODAL: 'images/hi/'
    },
    STYLES: {
        TAGGED_SHADOW: 'shadow-[0_4px_6px_-1px_rgba(180,83,9,0.5),0_2px_4px_-1px_rgba(217,119,6,0.35)]',
        TAGGED_HOVER_SHADOW: 'hover:shadow-[0_10px_15px_-3px_rgba(180,83,9,0.5),0_4px_6px_-2px_rgba(217,119,6,0.35)]',
        DEFAULT_SHADOW: 'shadow-md',
        DEFAULT_HOVER_SHADOW: 'hover:shadow-xl'
    }
};

// ============================================================================
// RECIPE DATABASE CLASS
// ============================================================================

class RecipeDatabase {
    constructor() {
        this.recipes = [
            {"id":"recipe_1755874440324_k3zjgdsow","title":"Aftenbladets Sjokoladekake","servings":"12 porsjoner","provider":"Aftenbladet","reference":"Oppskriftsbok","pageNumber":61,"category":"Lagkaker","meal":"Kake","cuisine":"Norsk","description":"Luftig sjokoladelagkake med tre lag og fyldig sjokoladekrem av melk, sukker og eggeplommer. Den lyse bunnen deles opp og fylles med en rik, hjemmelaget krem som gir en perfekt balanse mellom lett kakebunn og kremete fyll. Mandlene på toppen tilfører sprøhet og en nøtteaktig kontrast. Kaken har en dyp sjokoladesmak uten å være for søt, og egner seg utmerket til festlige anledninger eller søndagskos.","image":"aftenbladetssjokoladekake.jpg","ingredients":[{"group":"Kakebunn","items":["4 egg","200 g sukker","200 g hvetemel","2 ts bakepulver","100 g smør eller margarin (smeltet)"]},{"group":"Sjokoladekrem","items":["200 g sukker","6 ss melk","1 plate mørk kokesjokolade (ca. 100 g)","2 eggeplommer"]},{"group":"Pynt","items":["Høvlede mandler"]}],"instructions":["Pisk egg og sukker til en luftig eggedosis.","Sikt sammen mel og bakepulver og vend forsiktig inn i eggedosisen.","Rør inn smeltet smør.","Hell røren i en smurt kakeform (ca. 24 cm).","Stek ved 180–190 °C i ca. 35–40 minutter.","Avkjøl kaken helt og del den i tre lag.","Lag kremen: Pisk sukker og melk til hvitt og luftig. Rør inn smeltet kokesjokolade og tilsett eggeplommene.","Fyll kaken lagvis med kremen og dekk toppen.","Pynt med høvlede mandler."],"createdAt":"2025-08-22"},
            {"id":"recipe_1755530008601_5c9sko0oi","title":"Wienerring","servings":"1 stor ring","provider":"Farmor","reference":"Oppskriftsbok","pageNumber":18,"category":"Gjærbakst","meal":"Kaffe","cuisine":"Dansk","description":"Dekorativ wienerring med synlig kremfyll som bobler frem under steking. Den milde vaniljekremen komplimenterer den søte gjærdeigen. Klippingen skaper vakker presentasjon. Perfekt sentrum på festbordet.","image":"wienerring.jpg","ingredients":[{"group":"Deig","items":["250 g hvetemel","50 g sukker","ca. 1 ¼ dl melk (lunken)","1 egg","40 g gjær","100 g smør","1 egg til pensling","Litt hakkede mandler til pynt"]},{"group":"Fyll","items":["1 eggeplomme","1 ½ dl fløte","½ ts vaniljesukker","1 ss potetmel","1 ss sukker"]}],"instructions":["Sikt sammen hvetemel og sukker i en bolle.","Løs opp gjæren i lunken melk og pisk inn egget.","Bland væsken i det tørre og elt deigen til den er smidig. Arbeid inn smøret til slutt. La heve til dobbel størrelse.","Lag fyllet: Pisk sammen fløte, eggeplomme, sukker, potetmel og vaniljesukker. Kok forsiktig opp under omrøring til en tykk krem. Avkjøl.","Kjevle deigen ut til et stort rektangel og fordel fyllet jevnt utover.","Rull deigen sammen fra langsiden til en lang pølse og legg den på et stekebrett med bakepapir.","Form pølsen til en stor ring og klem endene godt sammen.","Klipp skrå snitt med ca. 3 cm mellomrom nesten helt igjennom, og vri hvert stykke litt utover så fyllet synes.","Pensle med egg og dryss over hakkede mandler.","Stek ved 180 °C (varmluft) eller 200 °C (over- og undervarme) i ca. 25–30 minutter til den er gyllenbrun."],"createdAt":"2025-08-18"}
        ];
    }

    findById(recipeId) {
        return this.recipes.find(recipe => recipe.id === recipeId);
    }

    getAllIds() {
        return this.recipes.map(r => r.id);
    }

    getAll() {
        return [...this.recipes];
    }

    getFilters() {
        const categories = new Set();
        const meals = new Set();
        const cuisines = new Set();
        
        this.recipes.forEach(recipe => {
            if (recipe.category) categories.add(recipe.category);
            if (recipe.meal) meals.add(recipe.meal);
            if (recipe.cuisine) cuisines.add(recipe.cuisine);
        });
        
        return {
            categories: Array.from(categories).sort(),
            meals: Array.from(meals).sort(),
            cuisines: Array.from(cuisines).sort()
        };
    }
}

// ============================================================================
// USER DATA MANAGER CLASS
// ============================================================================

class UserDataManager {
    constructor() {
        this.userData = {};
        this.load();
    }

    load() {
        const storedUserData = localStorage.getItem('userData');
        if (storedUserData) {
            this.userData = JSON.parse(storedUserData);
        }
    }

    save() {
        localStorage.setItem('userData', JSON.stringify(this.userData));
    }

    initializeRecipe(recipeId) {
        if (!this.userData[recipeId]) {
            this.userData[recipeId] = {
                userRating: null,
                madeDates: [],
                lastViewed: null,
                viewCount: 0,
                favorite: false,
                tagged: false,
                taggedAt: null
            };
        }
    }

    getRecipeData(recipeId) {
        return this.userData[recipeId] || {
            userRating: null,
            madeDates: [],
            lastViewed: null,
            viewCount: 0,
            favorite: false,
            tagged: false,
            taggedAt: null
        };
    }

    setRating(recipeId, rating) {
        this.initializeRecipe(recipeId);
        this.userData[recipeId].userRating = rating;
        this.save();
    }

    clearRating(recipeId) {
        if (this.userData[recipeId]) {
            this.userData[recipeId].userRating = null;
            this.save();
        }
    }

    toggleTag(recipeId) {
        this.initializeRecipe(recipeId);
        const isTagged = !this.userData[recipeId].tagged;
        this.userData[recipeId].tagged = isTagged;
        this.userData[recipeId].taggedAt = isTagged ? new Date().toISOString() : null;
        this.save();
        return isTagged;
    }

    toggleMadeToday(recipeId) {
        this.initializeRecipe(recipeId);
        const today = new Date().toISOString().split('T')[0];
        const madeDates = this.userData[recipeId].madeDates || [];
        
        const todayIndex = madeDates.indexOf(today);
        if (todayIndex > -1) {
            madeDates.splice(todayIndex, 1);
        } else {
            madeDates.push(today);
        }
        
        this.userData[recipeId].madeDates = madeDates;
        this.save();
        
        return {
            madeToday: madeDates.includes(today),
            madeCount: madeDates.length
        };
    }

    trackView(recipeId) {
        this.initializeRecipe(recipeId);
        this.userData[recipeId].lastViewed = new Date().toISOString();
        this.userData[recipeId].viewCount = (this.userData[recipeId].viewCount || 0) + 1;
        this.save();
    }

    getRecipeWithUserData(recipe) {
        const userInfo = this.getRecipeData(recipe.id);
        return { ...recipe, ...userInfo };
    }
}

// ============================================================================
// URL MANAGER CLASS
// ============================================================================

class URLManager {
    constructor(filterManager, modalManager, recipeDatabase) {
        this.filterManager = filterManager;
        this.modalManager = modalManager;
        this.recipeDatabase = recipeDatabase;
        this.baseURL = 'https://kkollsga.github.io/kokebok/';
        this.isUpdatingFromURL = false;
    }

    // Initialize from URL parameters on page load
    initializeFromURL() {
        const params = new URLSearchParams(window.location.search);
        
        // Handle filters - params.get automatically decodes %3A back to :
        const filterParam = params.get('filter');
        if (filterParam) {
            // The filter string is already decoded by params.get()
            // So "category%3ADrikke" becomes "category:Drikke"
            const filters = filterParam.split(',');
            filters.forEach(filter => {
                if (filter.includes(':')) {
                    this.filterManager.activeFilters.set(filter, true);
                }
            });
            this.filterManager.renderFilterPills();
            this.filterManager.updateFilterButton();
        }
        
        // Handle recipe modal
        const recipeParam = params.get('recipe');
        if (recipeParam) {
            const recipe = this.recipeDatabase.getAll().find(r => 
                r.title.toLowerCase() === recipeParam.toLowerCase()
            );
            
            if (recipe) {
                setTimeout(() => {
                    this.modalManager.showRecipe(recipe.id);
                }, 100);
            }
        }
    }

    // Update browser URL without reloading
    updateURL() {
        if (this.isUpdatingFromURL) return;
        
        // Build URL manually to avoid double encoding issues
        const parts = [];
        
        // Add active filters
        if (this.filterManager.activeFilters.size > 0) {
            const activeFilters = Array.from(this.filterManager.activeFilters.keys())
                .filter(key => this.filterManager.activeFilters.get(key));
            if (activeFilters.length > 0) {
                // Don't encode the colons in filters
                parts.push('filter=' + activeFilters.join(','));
            }
        }
        
        // Add open recipe
        if (this.modalManager.currentRecipeId) {
            const recipe = this.recipeDatabase.findById(this.modalManager.currentRecipeId);
            if (recipe) {
                parts.push('recipe=' + encodeURIComponent(recipe.title));
            }
        }
        
        // Update browser URL
        const newURL = parts.length > 0 ? '?' + parts.join('&') : '';
        const fullURL = window.location.pathname + newURL;
        
        window.history.replaceState({
            filters: Array.from(this.filterManager.activeFilters),
            recipeId: this.modalManager.currentRecipeId
        }, '', fullURL);
    }

    // Get shareable URL for current state
    getShareableURL() {
        const parts = [];
        
        // Add active filters
        if (this.filterManager.activeFilters.size > 0) {
            const activeFilters = Array.from(this.filterManager.activeFilters.keys())
                .filter(key => this.filterManager.activeFilters.get(key));
            if (activeFilters.length > 0) {
                // Don't encode the colons in filters
                parts.push('filter=' + activeFilters.join(','));
            }
        }
        
        // Add open recipe
        if (this.modalManager.currentRecipeId) {
            const recipe = this.recipeDatabase.findById(this.modalManager.currentRecipeId);
            if (recipe) {
                parts.push('recipe=' + encodeURIComponent(recipe.title));
            }
        }
        
        return parts.length > 0 ? `${this.baseURL}?${parts.join('&')}` : this.baseURL;
    }

    // Get shareable URL for specific recipe
    getRecipeURL(recipeId) {
        const recipe = this.recipeDatabase.findById(recipeId);
        if (!recipe) return this.baseURL;
        
        return `${this.baseURL}?recipe=${encodeURIComponent(recipe.title)}`;
    }

    // Copy URL to clipboard with visual feedback
    async copyToClipboard(url, buttonElement) {
        try {
            await navigator.clipboard.writeText(url);
            
            // Visual feedback
            if (buttonElement) {
                const originalHTML = buttonElement.innerHTML;
                const originalClass = buttonElement.className;
                
                buttonElement.innerHTML = '<i class="fas fa-check"></i>';
                buttonElement.classList.add('text-green-600');
                
                setTimeout(() => {
                    buttonElement.innerHTML = originalHTML;
                    buttonElement.className = originalClass;
                }, 1500);
            }
            
            return true;
        } catch (err) {
            console.error('Failed to copy URL:', err);
            return false;
        }
    }

    // Setup browser history navigation
    setupHistoryListener() {
        window.addEventListener('popstate', (event) => {
            this.isUpdatingFromURL = true;
            
            if (event.state) {
                // Restore filters
                this.filterManager.activeFilters.clear();
                if (event.state.filters) {
                    event.state.filters.forEach(([key, value]) => {
                        this.filterManager.activeFilters.set(key, value);
                    });
                }
                this.filterManager.renderFilterPills();
                this.filterManager.updateFilterButton();
                this.filterManager.applyFilters();
                
                // Restore or close modal
                if (event.state.recipeId) {
                    this.modalManager.showRecipe(event.state.recipeId);
                } else if (this.modalManager.currentRecipeId) {
                    this.modalManager.closeRecipe();
                }
            } else {
                // No state - clear everything
                this.filterManager.clearAllFilters();
                if (this.modalManager.currentRecipeId) {
                    this.modalManager.closeRecipe();
                }
            }
            
            this.isUpdatingFromURL = false;
        });
    }
}

// ============================================================================
// FILTER MANAGER CLASS
// ============================================================================

class FilterManager {
    constructor(recipeDatabase, uiManager, recommendationEngine, userDataManager) {
        this.recipeDatabase = recipeDatabase;
        this.uiManager = uiManager;
        this.recommendationEngine = recommendationEngine;
        this.userDataManager = userDataManager;
        this.activeFilters = new Map();
        this.filterMenuOpen = false;
        this.searchQuery = '';
        this.collapsedSections = new Set(['category', 'meal', 'cuisine']);
        this.sortOrder = 'recommendation';
        this.urlManager = null; // Will be set by RecipeApp
    }

    setURLManager(urlManager) {
        this.urlManager = urlManager;
    }

    setupEventListeners() {
        // Search input
        document.getElementById('searchInput').addEventListener('input', (e) => {
            this.searchQuery = e.target.value.toLowerCase();
            this.applyFilters();
        });

        // Close filter menu on outside click
        document.addEventListener('click', (e) => {
            const menu = document.getElementById('filterMenu');
            const toggle = document.getElementById('filterToggle');
            
            if (this.filterMenuOpen && 
                !menu.contains(e.target) && 
                !toggle.contains(e.target)) {
                this.toggleFilterMenu();
            }
        });

        // Prevent body scroll when scrolling inside filter menu
        const filterMenu = document.getElementById('filterMenu');
        
        // Mouse wheel scrolling
        filterMenu.addEventListener('wheel', (e) => {
            const dropdown = filterMenu.querySelector('.absolute');
            if (dropdown && !dropdown.classList.contains('hidden')) {
                const filterOptions = document.getElementById('filterOptions');
                const isScrollable = filterOptions.scrollHeight > filterOptions.clientHeight;
                
                if (isScrollable) {
                    const isAtTop = filterOptions.scrollTop === 0;
                    const isAtBottom = Math.abs(filterOptions.scrollTop + filterOptions.clientHeight - filterOptions.scrollHeight) < 1;
                    
                    if ((e.deltaY < 0 && isAtTop) || (e.deltaY > 0 && isAtBottom)) {
                        e.preventDefault();
                    } else {
                        e.stopPropagation();
                    }
                } else {
                    e.preventDefault();
                }
            }
        }, { passive: false });

        // Touch scrolling for mobile
        let touchStartY = 0;
        
        filterMenu.addEventListener('touchstart', (e) => {
            const dropdown = filterMenu.querySelector('.absolute');
            if (dropdown && !dropdown.classList.contains('hidden')) {
                touchStartY = e.touches[0].clientY;
            }
        }, { passive: true });

        filterMenu.addEventListener('touchmove', (e) => {
            const dropdown = filterMenu.querySelector('.absolute');
            if (dropdown && !dropdown.classList.contains('hidden')) {
                const filterOptions = document.getElementById('filterOptions');
                const touchY = e.touches[0].clientY;
                const deltaY = touchStartY - touchY;
                
                const isAtTop = filterOptions.scrollTop === 0;
                const isAtBottom = Math.abs(filterOptions.scrollTop + filterOptions.clientHeight - filterOptions.scrollHeight) < 1;
                
                if ((deltaY < 0 && isAtTop) || (deltaY > 0 && isAtBottom)) {
                    e.preventDefault();
                }
            }
        }, { passive: false });
    }

    hasActiveSearchOrFilters() {
        return this.searchQuery.length > 0 || this.activeFilters.size > 0;
    }

    changeSortOrder(newOrder) {
        const previousOrder = this.sortOrder;
        this.sortOrder = newOrder;
        
        // Update visual state of sort buttons
        document.querySelectorAll('[data-sort]').forEach(btn => {
            if (btn.getAttribute('data-sort') === newOrder) {
                // Selected button - no hover effect
                btn.classList.remove('text-gray-700', 'hover:text-amber-600');
                btn.classList.add('bg-amber-500', 'text-white');
            } else {
                // Unselected buttons - with hover effect
                btn.classList.remove('bg-amber-500', 'text-white');
                btn.classList.add('text-gray-700', 'hover:text-amber-600');
            }
        });
        
        // If switching back to recommendation from another sort, recalculate scores
        if (newOrder === 'recommendation' && previousOrder !== 'recommendation') {
            this.recommendationEngine.calculateAllScores();
        }
        
        this.applyFilters();
    }

    activateFilter(filterType, filterValue, event) {
        if (event) {
            event.stopPropagation();
        }
        
        const filterKey = `${filterType}:${filterValue}`;
        
        // Close modal if it's open
        const modal = document.getElementById('recipeModal');
        if (!modal.classList.contains('hidden')) {
            recipeApp.modalManager.closeRecipe();  // Keep this as recipeApp since it needs the global reference
        }
        
        // Add filter if not already active
        if (!this.activeFilters.has(filterKey)) {
            this.activeFilters.set(filterKey, true);
            this.renderFilterPills();
            this.updateFilterButton();
            this.applyFilters();
            this.renderFilterOptions();
        }
    }

    toggleFilterSection(section, event) {
        if (event) {
            event.stopPropagation();
        }
        
        if (this.collapsedSections.has(section)) {
            this.collapsedSections.delete(section);
        } else {
            this.collapsedSections.add(section);
        }
        this.renderFilterOptions();
    }

    toggleFilterType(type) {
        if (this.activeFilters.has(type)) {
            this.activeFilters.delete(type);
        } else {
            this.activeFilters.set(type, true);
        }
        this.renderFilterPills();
        this.updateFilterButton();
        this.applyFilters();
        this.renderFilterOptions();
        
        // Update URL when filters change
        if (this.urlManager) {
            this.urlManager.updateURL();
        }
    }

    togglePillActive(type) {
        if (this.activeFilters.has(type)) {
            this.activeFilters.set(type, !this.activeFilters.get(type));
            this.renderFilterPills();
            this.applyFilters();
        }
    }

    removeFilter(type) {
        this.activeFilters.delete(type);
        this.renderFilterPills();
        this.updateFilterButton();
        this.applyFilters();
        this.renderFilterOptions();
        
        // Update URL when filters change
        if (this.urlManager) {
            this.urlManager.updateURL();
        }
    }

    clearAllFilters() {
        this.activeFilters.clear();
        this.renderFilterPills();
        this.updateFilterButton();
        this.applyFilters();
        this.renderFilterOptions();
        
        // Update URL when filters change
        if (this.urlManager) {
            this.urlManager.updateURL();
        }
    }

    toggleFilterMenu() {
        const menu = document.querySelector('#filterMenu > div');
        
        if (!this.filterMenuOpen) {
            this.renderFilterOptions();
            menu.classList.remove('hidden');
            this.filterMenuOpen = true;
        } else {
            menu.classList.add('hidden');
            this.filterMenuOpen = false;
        }
    }

    renderFilterOptions() {
        const container = document.getElementById('filterOptions');
        const filters = this.recipeDatabase.getFilters();
        
        container.innerHTML = '';
        
        // Category filters
        if (filters.categories.length > 0) {
            const isCollapsed = this.collapsedSections.has('category');
            const categorySection = document.createElement('div');
            categorySection.className = 'mb-2';
            
            // Collapsible header
            const categoryHeader = document.createElement('button');
            categoryHeader.className = 'w-full flex items-center justify-between text-xs font-semibold text-gray-500 uppercase tracking-wider px-2 py-2 hover:bg-gray-50 rounded transition-colors';
            categoryHeader.onclick = (e) => {
                e.stopPropagation();
                this.toggleFilterSection('category', e);
            };
            categoryHeader.innerHTML = `
                <span>Kategori</span>
                <i class="fas fa-chevron-${isCollapsed ? 'down' : 'up'} text-gray-400 text-xs transition-transform duration-200"></i>
            `;
            categorySection.appendChild(categoryHeader);
            
            // Collapsible content
            if (!isCollapsed) {
                const categoryContent = document.createElement('div');
                categoryContent.className = 'mt-1';
                
                filters.categories.forEach(category => {
                    const isSelected = this.activeFilters.has(`category:${category}`);
                    const option = document.createElement('label');
                    option.className = 'flex items-center justify-between p-2 hover:bg-amber-50 rounded-lg cursor-pointer transition-colors';
                    option.innerHTML = `
                        <span class="text-sm text-gray-700">${category}</span>
                        <input type="checkbox" 
                            ${isSelected ? 'checked' : ''} 
                            onchange="recipeApp.filterManager.toggleFilterType('category:${category}')"
                            onclick="event.stopPropagation()"
                            class="rounded border-gray-300 text-amber-600 focus:ring-amber-500 cursor-pointer checked:bg-amber-600 checked:border-amber-600">
                    `;
                    categoryContent.appendChild(option);
                });
                
                categorySection.appendChild(categoryContent);
            }
            
            container.appendChild(categorySection);
        }
        
        // Meal filters
        if (filters.meals.length > 0) {
            const isCollapsed = this.collapsedSections.has('meal');
            const mealSection = document.createElement('div');
            mealSection.className = 'mb-2';
            
            // Collapsible header
            const mealHeader = document.createElement('button');
            mealHeader.className = 'w-full flex items-center justify-between text-xs font-semibold text-gray-500 uppercase tracking-wider px-2 py-2 hover:bg-gray-50 rounded transition-colors';
            mealHeader.onclick = (e) => {
                e.stopPropagation();
                this.toggleFilterSection('meal', e);
            };
            mealHeader.innerHTML = `
                <span>Måltid</span>
                <i class="fas fa-chevron-${isCollapsed ? 'down' : 'up'} text-gray-400 text-xs transition-transform duration-200"></i>
            `;
            mealSection.appendChild(mealHeader);
            
            // Collapsible content
            if (!isCollapsed) {
                const mealContent = document.createElement('div');
                mealContent.className = 'mt-1';
                
                filters.meals.forEach(meal => {
                    const isSelected = this.activeFilters.has(`meal:${meal}`);
                    const option = document.createElement('label');
                    option.className = 'flex items-center justify-between p-2 hover:bg-amber-50 rounded-lg cursor-pointer transition-colors';
                    option.innerHTML = `
                        <span class="text-sm text-gray-700">${meal}</span>
                        <input type="checkbox" 
                            ${isSelected ? 'checked' : ''} 
                            onchange="recipeApp.filterManager.toggleFilterType('meal:${meal}')"
                            onclick="event.stopPropagation()"
                            class="rounded border-gray-300 text-amber-600 focus:ring-amber-500 cursor-pointer checked:bg-amber-600 checked:border-amber-600">
                    `;
                    mealContent.appendChild(option);
                });
                
                mealSection.appendChild(mealContent);
            }
            
            container.appendChild(mealSection);
        }
        
        // Cuisine filters
        if (filters.cuisines.length > 0) {
            const isCollapsed = this.collapsedSections.has('cuisine');
            const cuisineSection = document.createElement('div');
            cuisineSection.className = 'mb-2';
            
            // Collapsible header
            const cuisineHeader = document.createElement('button');
            cuisineHeader.className = 'w-full flex items-center justify-between text-xs font-semibold text-gray-500 uppercase tracking-wider px-2 py-2 hover:bg-gray-50 rounded transition-colors';
            cuisineHeader.onclick = (e) => {
                e.stopPropagation();
                this.toggleFilterSection('cuisine', e);
            };
            cuisineHeader.innerHTML = `
                <span>Kjøkken</span>
                <i class="fas fa-chevron-${isCollapsed ? 'down' : 'up'} text-gray-400 text-xs transition-transform duration-200"></i>
            `;
            cuisineSection.appendChild(cuisineHeader);
            
            // Collapsible content
            if (!isCollapsed) {
                const cuisineContent = document.createElement('div');
                cuisineContent.className = 'mt-1';
                
                filters.cuisines.forEach(cuisine => {
                    const isSelected = this.activeFilters.has(`cuisine:${cuisine}`);
                    const option = document.createElement('label');
                    option.className = 'flex items-center justify-between p-2 hover:bg-amber-50 rounded-lg cursor-pointer transition-colors';
                    option.innerHTML = `
                        <span class="text-sm text-gray-700">${cuisine}</span>
                        <input type="checkbox" 
                            ${isSelected ? 'checked' : ''} 
                            onchange="recipeApp.filterManager.toggleFilterType('cuisine:${cuisine}')"
                            onclick="event.stopPropagation()"
                            class="rounded border-gray-300 text-amber-600 focus:ring-amber-500 cursor-pointer checked:bg-amber-600 checked:border-amber-600">
                    `;
                    cuisineContent.appendChild(option);
                });
                
                cuisineSection.appendChild(cuisineContent);
            }
            
            container.appendChild(cuisineSection);
        }
    }

    renderFilterPills() {
        const container = document.getElementById('filterPillsContainer');
        const hasFilters = this.activeFilters.size > 0;
        
        container.innerHTML = '';
        
        // Hide pills if more than 3 filters
        if (this.activeFilters.size > 3) {
            container.style.maxWidth = '0';
            container.style.opacity = '0';
        } else {
            container.style.maxWidth = hasFilters ? '100%' : '0';
            container.style.opacity = hasFilters ? '1' : '0';
            
            let pillCount = 0;
            this.activeFilters.forEach((isActive, filterKey) => {
                if (pillCount >= 3) return;
                
                const [filterType, filterValue] = filterKey.split(':');
                const displayName = filterValue || filterKey;
                
                const pill = document.createElement('div');
                pill.className = `inline-flex items-center gap-1 px-3 py-1.5 rounded-full text-sm transition-all shadow-sm max-w-[150px] ${
                    isActive 
                        ? 'bg-gradient-to-r from-amber-500 to-amber-600 text-white' 
                        : 'bg-gray-200 text-gray-500 opacity-60'
                }`;
                pill.innerHTML = `
                    <span class="cursor-pointer font-medium overflow-hidden text-ellipsis whitespace-nowrap max-w-[120px]" 
                            onclick="recipeApp.filterManager.togglePillActive('${filterKey}')">${displayName}</span>
                    <button onclick="recipeApp.filterManager.removeFilter('${filterKey}')" class="ml-1 hover:opacity-70 flex-shrink-0">
                        <i class="fas fa-times text-xs"></i>
                    </button>
                `;
                container.appendChild(pill);
                pillCount++;
            });
        }
        
        // Update button visibility
        const clearBtn = document.getElementById('clearFilters');
        
        if (hasFilters) {
            // Show clear button
            clearBtn.classList.remove('hidden');
        } else {
            // Hide clear button
            clearBtn.classList.add('hidden');
        }
    }

    updateFilterButton() {
        const btn = document.getElementById('filterToggle');
        const count = document.getElementById('filterCount');
        const hasFilters = this.activeFilters.size > 0;
        
        btn.className = 'flex items-center space-x-2 px-4 py-2 rounded-xl transition-all text-sm font-medium shrink-0 shadow-sm hover:shadow-md';
        
        if (hasFilters) {
            btn.classList.add('bg-gradient-to-r', 'from-amber-500', 'to-amber-600', 'text-white', 'hover:from-amber-600', 'hover:to-amber-700');
            count.textContent = this.activeFilters.size;
            count.classList.remove('hidden');
            count.classList.add('bg-white/30');
        } else {
            btn.classList.add('bg-white', 'text-gray-700', 'hover:text-amber-600', 'border', 'border-gray-200');
            count.classList.add('hidden');
        }
    }

    applyFilters() {
        let filtered = this.recipeDatabase.getAll();
        
        // Apply category/meal/cuisine filters
        const activeCategoryFilters = [];
        const activeMealFilters = [];
        const activeCuisineFilters = [];
        
        this.activeFilters.forEach((isActive, filterKey) => {
            if (!isActive) return;
            
            const [filterType, filterValue] = filterKey.split(':');
            if (filterType === 'category') {
                activeCategoryFilters.push(filterValue);
            } else if (filterType === 'meal') {
                activeMealFilters.push(filterValue);
            } else if (filterType === 'cuisine') {
                activeCuisineFilters.push(filterValue);
            }
        });
        
        // Filter by category
        if (activeCategoryFilters.length > 0) {
            filtered = filtered.filter(recipe => 
                activeCategoryFilters.includes(recipe.category)
            );
        }
        
        // Filter by meal type
        if (activeMealFilters.length > 0) {
            filtered = filtered.filter(recipe => 
                activeMealFilters.includes(recipe.meal)
            );
        }
        
        // Filter by cuisine type
        if (activeCuisineFilters.length > 0) {
            filtered = filtered.filter(recipe => 
                activeCuisineFilters.includes(recipe.cuisine)
            );
        }
        
        // Apply search filter
        if (this.searchQuery) {
            filtered = filtered.filter(recipe => {
                const titleMatch = recipe.title.toLowerCase().includes(this.searchQuery);
                
                let ingredientMatch = false;
                if (recipe.ingredients) {
                    recipe.ingredients.forEach(item => {
                        if (typeof item === 'string') {
                            if (item.toLowerCase().includes(this.searchQuery)) {
                                ingredientMatch = true;
                            }
                        } else if (item.items) {
                            item.items.forEach(ing => {
                                if (ing.toLowerCase().includes(this.searchQuery)) {
                                    ingredientMatch = true;
                                }
                            });
                        }
                    });
                }
                
                return titleMatch || ingredientMatch;
            });
        }
        
        // Separate tagged and untagged recipes
        const taggedRecipes = [];
        const untaggedRecipes = [];
        
        filtered.forEach(recipe => {
            const userData = this.userDataManager.getRecipeData(recipe.id);
            if (userData.tagged) {
                taggedRecipes.push({
                    recipe,
                    taggedAt: userData.taggedAt
                });
            } else {
                untaggedRecipes.push(recipe);
            }
        });
        
        // Sort tagged recipes by taggedAt (newest first)
        taggedRecipes.sort((a, b) => {
            const dateA = new Date(a.taggedAt || 0);
            const dateB = new Date(b.taggedAt || 0);
            return dateB - dateA;
        });
        
        // Pre-calculate all data needed for sorting to avoid repeated calls
        const recipeDataCache = new Map();
        
        const getRecipeData = (recipe) => {
            if (recipeDataCache.has(recipe.id)) {
                return recipeDataCache.get(recipe.id);
            }
            
            const data = {
                recipe: recipe,
                score: this.recommendationEngine.getRecipeScore(recipe.id),
                rating: this.userDataManager.getRecipeData(recipe.id).userRating || 0,
                madeCount: this.userDataManager.getRecipeData(recipe.id).madeDates?.length || 0,
                pageNumber: recipe.pageNumber || Number.MAX_SAFE_INTEGER,
                title: recipe.title
            };
            
            recipeDataCache.set(recipe.id, data);
            return data;
        };
        
        // Helper comparison functions
        const compareByPageNumber = (dataA, dataB) => {
            if (dataA.pageNumber !== dataB.pageNumber) {
                return dataA.pageNumber - dataB.pageNumber;
            }
            return dataA.recipe.id.localeCompare(dataB.recipe.id);
        };
        
        const compareByRecommendation = (dataA, dataB) => {
            if (dataA.score !== dataB.score) {
                return dataB.score - dataA.score;
            }
            return compareByPageNumber(dataA, dataB);
        };
        
        // Apply sorting to untagged recipes based on current sort order
        const enrichedRecipes = untaggedRecipes.map(recipe => getRecipeData(recipe));
        
        switch(this.sortOrder) {
            case 'recommendation':
                enrichedRecipes.sort(compareByRecommendation);
                break;
            
            case 'alphabetical':
                enrichedRecipes.sort((a, b) => {
                    return a.title.localeCompare(b.title, 'no-NO');
                });
                break;
            
            case 'recipebook':
                enrichedRecipes.sort(compareByPageNumber);
                break;
            
            case 'madecount':
                enrichedRecipes.sort((a, b) => {
                    if (a.madeCount !== b.madeCount) {
                        return b.madeCount - a.madeCount;
                    }
                    return compareByRecommendation(a, b);
                });
                break;
            
            case 'rating':
                enrichedRecipes.sort((a, b) => {
                    if (a.rating !== b.rating) {
                        return b.rating - a.rating;
                    }
                    return compareByRecommendation(a, b);
                });
                break;
        }
        
        // Extract sorted recipes from enriched data
        const sortedUntaggedRecipes = enrichedRecipes.map(data => data.recipe);
        
        // Combine tagged (at top) with untagged
        const finalFiltered = [
            ...taggedRecipes.map(item => item.recipe),
            ...sortedUntaggedRecipes
        ];
        
        const filteredIds = finalFiltered.map(recipe => recipe.id);
        this.uiManager.renderRecipes(filteredIds, false);
    }
}

// ============================================================================
// IMAGE LOADER CLASS
// ============================================================================

class ImageLoader {
    constructor() {
        this.loadingRows = new Set();
        this.loadedImages = new Set();
        this.bufferRows = 20; // Extra rows to load beyond viewport
        this.scrollTimer = null;
        this.resizeTimer = null;
    }
    
    getColumnCount() {
        // Detect from the actual CSS grid
        const grid = document.getElementById('recipeGrid');
        if (!grid || !grid.firstElementChild) return 1;
        
        const gridWidth = grid.offsetWidth;
        const cardWidth = grid.firstElementChild.offsetWidth;
        const gap = 24; // 1.5rem gap from Tailwind gap-6
        
        // Calculate columns accounting for gaps
        const columns = Math.round((gridWidth + gap) / (cardWidth + gap));
        return Math.max(1, columns);
    }
    
    getVisibleRowRange() {
        const grid = document.getElementById('recipeGrid');
        const cards = Array.from(grid.children).filter(card => 
            card.style.display !== 'none'
        );
        
        if (cards.length === 0) return { start: 0, end: 0, totalRows: 0 };
        
        const columnCount = this.getColumnCount();
        const viewportTop = window.scrollY;
        const viewportBottom = viewportTop + window.innerHeight;
        
        let firstVisibleRow = null;
        let lastVisibleRow = null;
        
        // Calculate which rows are visible
        cards.forEach((card, index) => {
            const rect = card.getBoundingClientRect();
            const absoluteTop = rect.top + window.scrollY;
            const absoluteBottom = absoluteTop + rect.height;
            const row = Math.floor(index / columnCount);
            
            // Check if card is in or near viewport
            if (absoluteBottom > viewportTop && absoluteTop < viewportBottom) {
                if (firstVisibleRow === null) firstVisibleRow = row;
                lastVisibleRow = row;
            }
        });
        
        const totalRows = Math.ceil(cards.length / columnCount);
        
        return {
            start: Math.max(0, (firstVisibleRow ?? 0) - this.bufferRows),
            end: Math.min(totalRows - 1, (lastVisibleRow ?? 0) + this.bufferRows),
            totalRows: totalRows
        };
    }
    
    async loadRow(rowIndex) {
        if (this.loadingRows.has(rowIndex)) return;
        
        this.loadingRows.add(rowIndex);
        
        const grid = document.getElementById('recipeGrid');
        const cards = Array.from(grid.children).filter(card => 
            card.style.display !== 'none'
        );
        
        const columnCount = this.getColumnCount();
        const startIdx = rowIndex * columnCount;
        const endIdx = Math.min(startIdx + columnCount, cards.length);
        
        const loadPromises = [];
        
        for (let i = startIdx; i < endIdx; i++) {
            const card = cards[i];
            const img = card.querySelector('img[data-src]');
            
            if (img && !this.loadedImages.has(img)) {
                loadPromises.push(this.loadImage(img));
            }
        }
        
        // Load all images in the row simultaneously
        await Promise.all(loadPromises);
    }
    
    loadImage(img) {
        return new Promise((resolve) => {
            const src = img.getAttribute('data-src');
            if (!src || this.loadedImages.has(img)) {
                resolve();
                return;
            }
            
            this.loadedImages.add(img);
            const tempImg = new Image();
            
            tempImg.onload = () => {
                img.src = src;
                img.classList.add('opacity-100');
                img.removeAttribute('data-src');
                resolve();
            };
            
            tempImg.onerror = () => {
                // Still mark as loaded to prevent retries
                img.removeAttribute('data-src');
                resolve();
            };
            
            tempImg.src = src;
        });
    }
    
    async loadVisibleRows() {
        const { start, end } = this.getVisibleRowRange();
        
        // Load rows sequentially from top to bottom
        for (let row = start; row <= end; row++) {
            await this.loadRow(row);
        }
    }
    
    setupScrollHandler() {
        const handleScroll = () => {
            clearTimeout(this.scrollTimer);
            this.scrollTimer = setTimeout(() => {
                this.loadVisibleRows();
            }, 100);
        };
        
        window.addEventListener('scroll', handleScroll, { passive: true });
        
        // Handle resize events (column count might change)
        window.addEventListener('resize', () => {
            clearTimeout(this.resizeTimer);
            this.resizeTimer = setTimeout(() => {
                // Clear loading state on resize as grid might have changed
                this.loadingRows.clear();
                this.loadVisibleRows();
            }, 250);
        });
    }
    
    reset() {
        // Clear all tracking when filters change
        this.loadedImages.clear();
        this.loadingRows.clear();
    }
}

// ============================================================================
// UI MANAGER CLASS
// ============================================================================

class UIManager {
    constructor(recipeDatabase, userDataManager) {
        this.recipeDatabase = recipeDatabase;
        this.userDataManager = userDataManager;
        this.modalCallback = null; // Will be set later
        this.imageLoader = null; // Initialize as null
    }

    setModalCallback(callback) {
        this.modalCallback = callback;
    }

    formatSource(recipe) {
        let parts = [];
        if (recipe.provider) {
            parts.push(recipe.provider);
        }
        if (recipe.reference) {
            parts.push(recipe.reference);
        }
        if (recipe.pageNumber) {
            parts.push(`s. ${recipe.pageNumber}`);
        }
        return parts.join(' • ');
    }

    renderStars(rating) {
        let stars = '';
        for (let i = 1; i <= 5; i++) {
            if (i <= rating) {
                stars += '<i class="fas fa-star text-amber-400 transition-all duration-200 hover:scale-125"></i>';
            } else {
                stars += '<i class="far fa-star text-gray-300 transition-all duration-200 hover:scale-125"></i>';
            }
        }
        return stars;
    }

    updateRecipeCardTag(recipeId, isTagged) {
        const cards = document.querySelectorAll(`[data-recipe-id="${recipeId}"]`);
        cards.forEach(card => {
            if (isTagged) {
                // Add amber shadow with same size as default
                card.classList.remove(CONFIG.STYLES.DEFAULT_SHADOW, CONFIG.STYLES.DEFAULT_HOVER_SHADOW);
                card.classList.add(...CONFIG.STYLES.TAGGED_SHADOW.split(' '), ...CONFIG.STYLES.TAGGED_HOVER_SHADOW.split(' '));
                
                // Add tag indicator if not present
                const imageContainer = card.querySelector('.h-48');
                if (imageContainer && !imageContainer.querySelector('.fa-tag')) {
                    const tagBadge = document.createElement('span');
                    tagBadge.className = 'absolute top-2 left-2 bg-yellow-600 text-white text-xs font-bold px-2 py-1 rounded-full';
                    tagBadge.innerHTML = '<i class="fas fa-tag"></i>';
                    imageContainer.appendChild(tagBadge);
                }
            } else {
                // Remove amber shadow
                card.classList.remove(...CONFIG.STYLES.TAGGED_SHADOW.split(' '), ...CONFIG.STYLES.TAGGED_HOVER_SHADOW.split(' '));
                card.classList.add(CONFIG.STYLES.DEFAULT_SHADOW, CONFIG.STYLES.DEFAULT_HOVER_SHADOW);
                
                // Remove tag indicator
                const tagBadge = card.querySelector('.fa-tag')?.parentElement;
                if (tagBadge && tagBadge.classList.contains('absolute')) {
                    tagBadge.remove();
                }
            }
        });
    }

    createRecipeCard(recipe) {
        const card = document.createElement('div');
        const isTagged = recipe.tagged || false;
        
        // Darker, more subtle glowing shadow effect (using darker amber/brown tones)
        const shadowClass = isTagged 
            ? `${CONFIG.STYLES.TAGGED_SHADOW} ${CONFIG.STYLES.TAGGED_HOVER_SHADOW}` 
            : `${CONFIG.STYLES.DEFAULT_SHADOW} ${CONFIG.STYLES.DEFAULT_HOVER_SHADOW}`;

        card.className = `bg-white rounded-xl ${shadowClass} overflow-hidden cursor-pointer transition-all duration-300 hover:-translate-y-1`;
        card.setAttribute('data-recipe-id', recipe.id);
        
        // Use data attribute instead of direct onclick
        card.setAttribute('data-recipe-click', recipe.id);
        
        const imageUrl = recipe.image ? CONFIG.IMAGE_PATHS.LIST + recipe.image : null;
        const sourceInfo = this.formatSource(recipe);
        
        card.innerHTML = `
            <div class="h-48 bg-gradient-to-br from-amber-100 to-orange-100 relative overflow-hidden">
                ${recipe.image ? 
                    `<img data-src="${imageUrl}"
                        loading="lazy"
                        alt="${recipe.title}" 
                        class="w-full h-full object-cover opacity-0 transition-opacity duration-300">` : 
                    `<div class="w-full h-full flex items-center justify-center">
                        <span class="text-6xl opacity-30">🍞</span>
                    </div>`}
                ${isTagged ? `<span class="absolute top-2 left-2 bg-yellow-600 text-white text-xs font-bold px-2 py-1 rounded-full">
                    <i class="fas fa-tag"></i>
                </span>` : ''}
                ${recipe.category ? `<span onclick="recipeApp.filterManager.activateFilter('category', '${recipe.category}', event)" 
                    class="absolute top-2 right-2 bg-white/90 backdrop-blur text-xs font-medium px-2 py-1 rounded-full text-amber-700 transition-all duration-200 cursor-pointer hover:scale-105 hover:shadow-lg">
                    ${recipe.category}
                </span>` : ''}
            </div>
            <div class="p-5">
                <h3 class="font-display text-xl text-gray-800 ${sourceInfo ? 'mb-0' : 'mb-2'}">${recipe.title}</h3>
                ${sourceInfo ? `<p class="text-xs text-amber-600 mb-2">${sourceInfo}</p>` : ''}
                ${recipe.description ? `<p class="text-gray-500 text-xs mb-3 overflow-hidden line-clamp-2">${recipe.description}</p>` : ''}
                <div class="flex items-center justify-between gap-2">
                    <div class="recipe-stars flex items-center space-x-1 flex-shrink-0">
                        ${this.renderStars(recipe.userRating || 0)}
                    </div>
                    <div class="flex items-center gap-2 flex-wrap justify-end">
                        ${recipe.cuisine ? 
                            `<span onclick="recipeApp.filterManager.activateFilter('cuisine', '${recipe.cuisine}', event)" 
                                class="inline-block px-2 py-0.5 bg-gray-100 rounded-full text-xs cursor-pointer hover:bg-amber-100 transition-all duration-200 hover:scale-105">
                                ${recipe.cuisine}
                            </span>` : ''}
                        ${recipe.meal ? 
                            `<span onclick="recipeApp.filterManager.activateFilter('meal', '${recipe.meal}', event)" 
                                class="inline-block px-2 py-0.5 bg-gray-100 rounded-full text-xs cursor-pointer hover:bg-amber-100 transition-all duration-200 hover:scale-105">
                                ${recipe.meal}
                            </span>` : ''}
                        <div class="flex items-center ml-2 text-sm text-gray-600">
                            <i class="fas fa-utensils mr-1"></i>
                            <span class="recipe-counter">${recipe.madeDates ? recipe.madeDates.length : 0}</span>
                        </div>
                    </div>
                </div>
            </div>
        `;
        
        return card;
    }

    renderRecipes(recipesToRender = null, forceFullRender = false) {
        const grid = document.getElementById('recipeGrid');
        const recipeIds = recipesToRender || this.recipeDatabase.getAllIds();
        
        // If force full render or grid is empty
        if (forceFullRender || grid.children.length === 0) {
            grid.innerHTML = '';
            recipeIds.forEach(recipeId => {
                const recipe = this.recipeDatabase.findById(recipeId);
                if (recipe) {
                    const recipeWithUserData = this.userDataManager.getRecipeWithUserData(recipe);
                    const card = this.createRecipeCard(recipeWithUserData);
                    grid.appendChild(card);
                }
            });
            this.setupLazyLoading();
            this.setupCardClickHandlers();
            return;
        }
        
        // Smart update: hide/show/reorder existing cards
        const existingCards = new Map();
        Array.from(grid.children).forEach(card => {
            const id = card.getAttribute('data-recipe-id');
            existingCards.set(id, card);
        });
        
        // Hide cards not in the filter
        existingCards.forEach((card, id) => {
            if (!recipeIds.includes(id)) {
                card.style.display = 'none';
            } else {
                card.style.display = '';
            }
        });
        
        // Reorder cards if needed
        const fragment = document.createDocumentFragment();
        recipeIds.forEach(recipeId => {
            if (existingCards.has(recipeId)) {
                const card = existingCards.get(recipeId);
                card.style.display = '';
                fragment.appendChild(card);
            } else {
                // Create new card if it doesn't exist
                const recipe = this.recipeDatabase.findById(recipeId);
                if (recipe) {
                    const recipeWithUserData = this.userDataManager.getRecipeWithUserData(recipe);
                    const card = this.createRecipeCard(recipeWithUserData);
                    fragment.appendChild(card);
                }
            }
        });
        
        grid.innerHTML = '';
        grid.appendChild(fragment);
        
        // Reset image loader and load visible rows
        requestAnimationFrame(() => {
            if (this.imageLoader) {
                this.imageLoader.reset();
                this.imageLoader.loadVisibleRows();
            }
        });
        
        this.setupCardClickHandlers();
    }

    setupCardClickHandlers() {
        // Setup click handlers for all recipe cards
        document.querySelectorAll('[data-recipe-click]').forEach(card => {
            card.onclick = (e) => {
                // Don't trigger if clicking on category filter
                if (e.target.closest('[onclick*="activateFilter"]')) {
                    return;
                }
                const recipeId = card.getAttribute('data-recipe-click');
                if (this.modalCallback) {
                    this.modalCallback(recipeId);
                }
            };
        });
    }

    setupLazyLoading() {
        // Create image loader if it doesn't exist
        if (!this.imageLoader) {
            this.imageLoader = new ImageLoader();
            this.imageLoader.setupScrollHandler();
        }
        
        // Load visible rows immediately
        this.imageLoader.loadVisibleRows();
    }

    updateRecipeCardRating(recipeId, rating) {
        const cards = document.querySelectorAll(`[data-recipe-id="${recipeId}"]`);
        cards.forEach(card => {
            const stars = card.querySelectorAll('.recipe-stars i');
            stars.forEach((star, index) => {
                if (index < rating) {
                    star.classList.remove('far', 'text-gray-300');
                    star.classList.add('fas', 'text-amber-400');
                } else {
                    star.classList.remove('fas', 'text-amber-400');
                    star.classList.add('far', 'text-gray-300');
                }
            });
        });
    }

    updateRecipeCardCounter(recipeId, count) {
        const cards = document.querySelectorAll(`[data-recipe-id="${recipeId}"]`);
        cards.forEach(card => {
            const counterElement = card.querySelector('.recipe-counter');
            if (counterElement && counterElement.textContent !== count.toString()) {
                counterElement.textContent = count;
                // Add a subtle animation
                counterElement.style.transform = 'scale(1.2)';
                setTimeout(() => {
                    counterElement.style.transform = 'scale(1)';
                }, 200);
            }
        });
    }
}

// ============================================================================
// KOKEBOK VIEWER CLASS - UPDATED
// ============================================================================

class KokebokViewer {
    constructor() {
        this.currentPage = 1;
        this.totalPages = 150;
        this.zoomLevel = 1;
        this.minZoom = 1;
        this.maxZoom = 5;
        this.panX = 0;
        this.panY = 0;
        this.isPanning = false;
        this.startX = 0;
        this.startY = 0;
        this.touchStartDistance = 0;
        this.initialZoom = 1;
        this.initialPanX = 0;
        this.initialPanY = 0;
        this.modalElement = null;
        this.imageElement = null;
        this.containerElement = null;
        this.isOpen = false;
        this.eventListenersAttached = false;
        this.loadedImageUrls = new Set(); // Track loaded kokebok images
        this.createModal();
        
        // Store bound event handlers for proper removal
        this.boundHandlers = {
            wheel: null,
            mousedown: null,
            mousemove: null,
            mouseup: null,
            touchstart: null,
            touchmove: null,
            touchend: null,
            keydown: null,
            orientationchange: null,
            resize: null
        };
    }

    createModal() {
        const modal = document.createElement('div');
        modal.id = 'kokebokViewer';
        modal.className = 'absolute inset-0 top-20 bg-white hidden z-[60] flex flex-col rounded-t-2xl overflow-hidden shadow-2xl border border-amber-200';
        
        modal.innerHTML = `
            <button onclick="recipeApp.kokebokViewer.close()" 
                    class="absolute top-3 right-3 z-10 text-amber-700 hover:text-amber-500 transition-all duration-200 p-2"
                    style="filter: drop-shadow(0 2px 4px rgba(0,0,0,0.2));">
                <i class="fas fa-times text-xl"></i>
            </button>
            
            <div id="kokebokContainer" class="flex-1 overflow-hidden relative bg-gradient-to-br from-amber-50/30 to-orange-50/30">
                <div id="kokebokImageWrapper" class="w-full h-full flex items-center justify-center">
                    <img id="kokebokImage" 
                         class="max-w-none cursor-move select-none shadow-lg"
                         draggable="false"
                         style="transform-origin: center center;">
                </div>
            </div>
            
            <div class="bg-white border-t border-amber-200 px-4 py-2">
                <div class="flex items-center justify-center gap-2">
                    <button onclick="recipeApp.kokebokViewer.previousPage()" 
                            class="px-3 py-1.5 bg-white hover:bg-amber-50 text-amber-700 rounded-lg border border-amber-300 disabled:opacity-50 disabled:cursor-not-allowed"
                            id="prevPageBtn">
                        <i class="fas fa-chevron-left"></i>
                    </button>
                    <div class="px-4 py-1.5 bg-amber-100 text-amber-800 rounded-lg min-w-[100px] text-center font-medium text-sm border border-amber-300">
                        <span id="pageIndicator">Side 1</span>
                    </div>
                    <button onclick="recipeApp.kokebokViewer.nextPage()" 
                            class="px-3 py-1.5 bg-white hover:bg-amber-50 text-amber-700 rounded-lg border border-amber-300 disabled:opacity-50 disabled:cursor-not-allowed"
                            id="nextPageBtn">
                        <i class="fas fa-chevron-right"></i>
                    </button>
                </div>
            </div>
        `;
        
        this.modalElement = modal;
    }

    updateModalPosition() {
        const windowWidth = window.innerWidth;
        const windowHeight = window.innerHeight;
        const isLandscape = windowWidth > windowHeight;
        const isFullscreen = windowWidth <= 1000;
        
        if (isLandscape && windowWidth <= 900) {
            this.modalElement.className = 'absolute inset-0 bg-white hidden z-[60] flex flex-col overflow-hidden shadow-2xl border border-amber-200';
        } else if (isFullscreen) {
            this.modalElement.className = 'absolute inset-0 top-20 bg-white hidden z-[60] flex flex-col rounded-t-2xl overflow-hidden shadow-2xl border border-amber-200';
        } else {
            this.modalElement.className = 'absolute inset-0 top-20 bg-white hidden z-[60] flex flex-col rounded-2xl overflow-hidden shadow-2xl border border-amber-200';
        }
    }

    setupEventListeners() {
        if (this.eventListenersAttached) return;
        this.eventListenersAttached = true;

        // Create bound handlers that we can properly remove later
        this.boundHandlers.wheel = (e) => {
            e.preventDefault();
            e.stopPropagation();
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            this.zoom(delta, e.clientX, e.clientY);
        };

        this.boundHandlers.mousedown = (e) => {
            e.preventDefault();
            e.stopPropagation();
            this.startPanning(e.clientX, e.clientY);
        };

        this.boundHandlers.mousemove = (e) => {
            if (this.isPanning && this.imageElement) {
                this.pan(e.clientX, e.clientY);
            }
        };

        this.boundHandlers.mouseup = () => {
            if (this.isPanning) {
                this.stopPanning();
            }
        };

        this.boundHandlers.touchstart = (e) => {
            e.stopPropagation();
            if (e.touches.length === 1) {
                const touch = e.touches[0];
                this.startPanning(touch.clientX, touch.clientY);
            } else if (e.touches.length === 2) {
                e.preventDefault();
                this.isPanning = false;
                
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                
                this.touchStartDistance = Math.hypot(
                    touch2.clientX - touch1.clientX,
                    touch2.clientY - touch1.clientY
                );
                
                this.initialZoom = this.zoomLevel;
                this.initialPanX = this.panX;
                this.initialPanY = this.panY;
                
                const rect = this.containerElement.getBoundingClientRect();
                this.pinchCenterX = ((touch1.clientX + touch2.clientX) / 2) - rect.left;
                this.pinchCenterY = ((touch1.clientY + touch2.clientY) / 2) - rect.top;
            }
        };

        this.boundHandlers.touchmove = (e) => {
            if (e.touches.length === 1 && this.isPanning) {
                const touch = e.touches[0];
                this.pan(touch.clientX, touch.clientY);
            } else if (e.touches.length === 2) {
                e.preventDefault();
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                
                const currentDistance = Math.hypot(
                    touch2.clientX - touch1.clientX,
                    touch2.clientY - touch1.clientY
                );
                
                if (this.touchStartDistance > 0) {
                    const scale = currentDistance / this.touchStartDistance;
                    const newZoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.initialZoom * scale));
                    
                    const zoomDelta = newZoom / this.zoomLevel;
                    
                    this.panX = this.pinchCenterX - (this.pinchCenterX - this.panX) * zoomDelta;
                    this.panY = this.pinchCenterY - (this.pinchCenterY - this.panY) * zoomDelta;
                    
                    this.zoomLevel = newZoom;
                    this.updateTransform();
                }
            }
        };

        this.boundHandlers.touchend = (e) => {
            if (e.touches.length === 0) {
                this.stopPanning();
                this.touchStartDistance = 0;
            } else if (e.touches.length === 1) {
                const touch = e.touches[0];
                this.startPanning(touch.clientX, touch.clientY);
            }
        };

        this.boundHandlers.keydown = (e) => {
            if (this.modalElement && !this.modalElement.classList.contains('hidden')) {
                switch(e.key) {
                    case 'Escape':
                        e.stopPropagation();
                        this.close();
                        break;
                    case 'ArrowLeft':
                        this.previousPage();
                        break;
                    case 'ArrowRight':
                        this.nextPage();
                        break;
                }
            }
        };

        this.boundHandlers.orientationchange = () => {
            if (this.isOpen) {
                setTimeout(() => {
                    this.updateModalPosition();
                    this.fitToPage();
                }, 100);
            }
        };

        this.boundHandlers.resize = () => {
            if (this.isOpen) {
                this.updateModalPosition();
                if (Math.abs(this.zoomLevel - this.minZoom) < 0.01) {
                    this.fitToPage();
                }
            }
        };

        // Add event listeners
        this.containerElement?.addEventListener('wheel', this.boundHandlers.wheel, { passive: false });
        this.imageElement?.addEventListener('mousedown', this.boundHandlers.mousedown);
        this.imageElement?.addEventListener('touchstart', this.boundHandlers.touchstart, { passive: false });
        this.imageElement?.addEventListener('touchmove', this.boundHandlers.touchmove, { passive: false });
        this.imageElement?.addEventListener('touchend', this.boundHandlers.touchend);
        
        document.addEventListener('mousemove', this.boundHandlers.mousemove);
        document.addEventListener('mouseup', this.boundHandlers.mouseup);
        document.addEventListener('keydown', this.boundHandlers.keydown);
        window.addEventListener('orientationchange', this.boundHandlers.orientationchange);
        window.addEventListener('resize', this.boundHandlers.resize);

        // Stop click propagation
        this.modalElement?.addEventListener('click', (e) => {
            e.stopPropagation();
        });
    }

    cleanupEventListeners() {
        if (!this.eventListenersAttached) return;
        
        // Remove element-specific listeners
        this.containerElement?.removeEventListener('wheel', this.boundHandlers.wheel);
        this.imageElement?.removeEventListener('mousedown', this.boundHandlers.mousedown);
        this.imageElement?.removeEventListener('touchstart', this.boundHandlers.touchstart);
        this.imageElement?.removeEventListener('touchmove', this.boundHandlers.touchmove);
        this.imageElement?.removeEventListener('touchend', this.boundHandlers.touchend);
        
        // Remove document/window listeners
        document.removeEventListener('mousemove', this.boundHandlers.mousemove);
        document.removeEventListener('mouseup', this.boundHandlers.mouseup);
        document.removeEventListener('keydown', this.boundHandlers.keydown);
        window.removeEventListener('orientationchange', this.boundHandlers.orientationchange);
        window.removeEventListener('resize', this.boundHandlers.resize);
        
        this.eventListenersAttached = false;
    }

    clearImageCache() {
        // Force browser to release memory for kokebok images
        if (this.imageElement) {
            // Clear event handlers first to prevent error on empty src
            this.imageElement.onload = null;
            this.imageElement.onerror = null;
            // Use transparent 1x1 data URL instead of empty string
            this.imageElement.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
        }
        
        // Clear each cached image URL from browser cache
        this.loadedImageUrls.forEach(url => {
            // Create a temporary image to force cache clear
            const img = new Image();
            img.src = url;
            img.src = ''; // Clear the src to help garbage collection
        });
        
        // Clear our tracking set
        this.loadedImageUrls.clear();
        
        // Force garbage collection hint (browser may or may not respect this)
        if (window.gc) {
            window.gc();
        }
    }

    open(pageNumber) {
        const recipeModal = document.getElementById('recipeModal');
        const modalContent = recipeModal?.querySelector('#modalContent') || recipeModal?.querySelector('.flex.flex-col');
        
        if (modalContent && !modalContent.contains(this.modalElement)) {
            modalContent.appendChild(this.modalElement);
            // Get references after DOM insertion
            this.imageElement = document.getElementById('kokebokImage');
            this.containerElement = document.getElementById('kokebokContainer');
            // Setup event listeners after elements exist
            this.setupEventListeners();
        }
        
        this.currentPage = pageNumber || 1;
        this.isOpen = true;
        this.updateModalPosition();
        this.loadPage(this.currentPage);
        this.modalElement.classList.remove('hidden');
    }

    close() {
        // Hide modal
        this.modalElement.classList.add('hidden');
        this.isOpen = false;
        this.isPanning = false;
        
        // Clean up event listeners to prevent memory leaks
        this.cleanupEventListeners();
        
        // Clear high-resolution image cache
        this.clearImageCache();
        
        // Reset zoom and pan for next opening
        this.zoomLevel = 1;
        this.panX = 0;
        this.panY = 0;
    }

    loadPage(pageNumber) {
        const paddedNumber = String(pageNumber).padStart(3, '0');
        const imageUrl = `images/kokebok/kokebok-page-${paddedNumber}.jpg`;
        
        // Track this URL for cache clearing
        this.loadedImageUrls.add(imageUrl);
        
        if (this.imageElement) {
            this.imageElement.src = imageUrl;
            this.imageElement.onload = () => {
                this.updatePageIndicator();
                this.updateNavigationButtons();
                this.fitToPage();
            };
            
            this.imageElement.onerror = () => {
                console.error(`Failed to load page ${pageNumber}`);
            };
        }
    }

    fitToPage() {
        if (!this.imageElement || !this.containerElement) return;
        
        const containerWidth = this.containerElement.clientWidth;
        const containerHeight = this.containerElement.clientHeight;
        const imageWidth = this.imageElement.naturalWidth || 1949;
        const imageHeight = this.imageElement.naturalHeight || 2456;
        
        const padding = 20;
        const scaleX = (containerWidth - padding) / imageWidth;
        const scaleY = (containerHeight - padding) / imageHeight;
        const scale = Math.min(scaleX, scaleY);
        
        this.zoomLevel = scale;
        this.minZoom = scale;
        this.panX = 0;
        this.panY = 0;
        this.updateTransform();
    }

    previousPage() {
        if (this.currentPage > 1) {
            this.currentPage--;
            this.loadPage(this.currentPage);
        }
    }

    nextPage() {
        if (this.currentPage < this.totalPages) {
            this.currentPage++;
            this.loadPage(this.currentPage);
        }
    }

    zoom(delta, clientX, clientY) {
        const newZoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.zoomLevel * delta));
        
        if (newZoom !== this.zoomLevel && this.containerElement) {
            const rect = this.containerElement.getBoundingClientRect();
            const x = clientX - rect.left;
            const y = clientY - rect.top;
            
            const zoomRatio = newZoom / this.zoomLevel;
            this.panX = x - (x - this.panX) * zoomRatio;
            this.panY = y - (y - this.panY) * zoomRatio;
            
            this.zoomLevel = newZoom;
            this.updateTransform();
        }
    }

    startPanning(x, y) {
        this.isPanning = true;
        this.startX = x - this.panX;
        this.startY = y - this.panY;
        if (this.imageElement) {
            this.imageElement.style.cursor = 'grabbing';
        }
    }

    pan(x, y) {
        if (this.isPanning) {
            this.panX = x - this.startX;
            this.panY = y - this.startY;
            this.updateTransform();
        }
    }

    stopPanning() {
        this.isPanning = false;
        if (this.imageElement) {
            this.imageElement.style.cursor = 'move';
        }
    }

    updateTransform() {
        if (this.imageElement) {
            this.imageElement.style.transform = `translate(${this.panX}px, ${this.panY}px) scale(${this.zoomLevel})`;
        }
    }

    updatePageIndicator() {
        const indicator = document.getElementById('pageIndicator');
        if (indicator) {
            indicator.textContent = `Side ${this.currentPage}`;
        }
    }

    updateNavigationButtons() {
        const prevBtn = document.getElementById('prevPageBtn');
        const nextBtn = document.getElementById('nextPageBtn');
        
        if (prevBtn) prevBtn.disabled = this.currentPage <= 1;
        if (nextBtn) nextBtn.disabled = this.currentPage >= this.totalPages;
    }
}

// ============================================================================
// MODAL MANAGER CLASS - UPDATED WITH ALL FIXES
// ============================================================================

class ModalManager {
    constructor(recipeDatabase, userDataManager, uiManager, recommendationEngine) {
        this.recipeDatabase = recipeDatabase;
        this.userDataManager = userDataManager;
        this.uiManager = uiManager;
        this.recommendationEngine = recommendationEngine;
        this.scrollPosition = 0;
        this.isFullscreen = false;
        this.currentRecipeId = null;
        this.completedSteps = new Map();
        this.activeStep = null;
        this.urlManager = null;
        
        // LRU cache for high-res images (max 5)
        this.imagePreloadCache = new Map();
        this.MAX_CACHE_SIZE = 5;
        
        // Track pending operations for cleanup
        this.pendingTimeouts = [];
        
        // Store bound event handlers for cleanup
        this.boundHandlers = {
            modalClick: null,
            resize: null,
            orientationchange: null,
            resizeTimer: null,
            orientationTimer: null
        };
        
        this.setupEventListeners();
    }

    setURLManager(urlManager) {
        this.urlManager = urlManager;
    }

    setupEventListeners() {
        // Create bound handler for modal click
        this.boundHandlers.modalClick = (e) => {
            const currentlyFullscreen = window.innerWidth <= CONFIG.BREAKPOINTS.FULLSCREEN_MODAL;
            if (!currentlyFullscreen) {
                const modalWrapper = e.currentTarget.firstElementChild?.firstElementChild;
                if (modalWrapper && !modalWrapper.contains(e.target)) {
                    this.closeRecipe();
                }
            }
        };
        
        // Add modal click listener
        document.getElementById('recipeModal').addEventListener('click', this.boundHandlers.modalClick);
        
        // Create bound handlers for window events
        this.boundHandlers.resize = () => {
            if (this.currentRecipeId) {
                clearTimeout(this.boundHandlers.resizeTimer);
                this.boundHandlers.resizeTimer = setTimeout(() => {
                    this.updateModalLayout();
                    const newIsFullscreen = window.innerWidth <= CONFIG.BREAKPOINTS.FULLSCREEN_MODAL;
                    if (newIsFullscreen !== this.isFullscreen) {
                        this.updateModalContent();
                    }
                }, 250);
            }
        };
        
        this.boundHandlers.orientationchange = (e) => {
            if (this.currentRecipeId) {
                e.preventDefault();
                const viewport = document.querySelector('meta[name="viewport"]');
                viewport.setAttribute('content', 
                    'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover'
                );
                
                clearTimeout(this.boundHandlers.orientationTimer);
                this.boundHandlers.orientationTimer = setTimeout(() => {
                    this.updateModalLayout();
                    this.updateModalContent();
                }, 100);
            }
        };
        
        // Add window event listeners
        window.addEventListener('resize', this.boundHandlers.resize);
        window.addEventListener('orientationchange', this.boundHandlers.orientationchange);
    }

    cleanupEventListeners() {
        // Clear any pending timers
        clearTimeout(this.boundHandlers.resizeTimer);
        clearTimeout(this.boundHandlers.orientationTimer);
        
        // Note: We don't remove the main event listeners since they're needed
        // for the lifetime of the app. They check if modal is open before doing work.
    }

    // LRU cache management for high-res images
    preloadHighResImage(recipe) {
        if (!recipe.image) return null;
        
        const highResUrl = CONFIG.IMAGE_PATHS.MODAL + recipe.image;
        
        // Check if already cached
        if (this.imagePreloadCache.has(highResUrl)) {
            // Move to end (most recently used)
            const cachedPromise = this.imagePreloadCache.get(highResUrl);
            this.imagePreloadCache.delete(highResUrl);
            this.imagePreloadCache.set(highResUrl, cachedPromise);
            return cachedPromise;
        }
        
        // Check cache size and evict oldest if needed
        if (this.imagePreloadCache.size >= this.MAX_CACHE_SIZE) {
            // Delete oldest (first) entry
            const firstKey = this.imagePreloadCache.keys().next().value;
            this.imagePreloadCache.delete(firstKey);
        }
        
        // Create and cache new image promise
        const imagePromise = new Promise((resolve) => {
            const img = new Image();
            img.onload = () => resolve(highResUrl);
            img.onerror = () => resolve(null);
            img.src = highResUrl;
        });
        
        this.imagePreloadCache.set(highResUrl, imagePromise);
        return imagePromise;
    }

    // Helper to add timeout operations that can be cancelled
    addPendingTimeout(fn, delay = 0) {
        const timeoutId = setTimeout(() => {
            // Remove from pending list when executed
            const index = this.pendingTimeouts.indexOf(timeoutId);
            if (index > -1) {
                this.pendingTimeouts.splice(index, 1);
            }
            fn();
        }, delay);
        
        this.pendingTimeouts.push(timeoutId);
        return timeoutId;
    }

    // Cancel all pending timeouts
    cancelPendingTimeouts() {
        this.pendingTimeouts.forEach(id => clearTimeout(id));
        this.pendingTimeouts = [];
    }

    // Clear steps for a specific recipe
    clearStepsForRecipe(recipeId) {
        Array.from(this.completedSteps.keys()).forEach(key => {
            if (key.startsWith(recipeId + '-')) {
                this.completedSteps.delete(key);
            }
        });
        if (this.activeStep && this.activeStep.startsWith(recipeId + '-')) {
            this.activeStep = null;
        }
    }

    // Main entry point - optimized for performance
    showRecipe(recipeId) {
        const recipe = this.recipeDatabase.findById(recipeId);
        if (!recipe) return;
        
        this.currentRecipeId = recipeId;
        
        // Lock body scroll immediately
        this.scrollPosition = window.pageYOffset;
        document.body.classList.add('modal-open');
        document.body.style.overflow = 'hidden';
        document.body.style.position = 'relative';
        document.documentElement.style.overflow = 'hidden';
        
        // Setup modal layout
        this.setupModalLayout();
        
        // Show modal with loading state IMMEDIATELY
        const modal = document.getElementById('recipeModal');
        const modalWrapper = modal.querySelector('#modalContent') || modal.querySelector('.flex.flex-col');
        
        // Simple loading state
        modalWrapper.innerHTML = `
            <div class="flex items-center justify-center h-full bg-gradient-to-br from-amber-100 to-orange-100 ${
                window.innerWidth <= CONFIG.BREAKPOINTS.FULLSCREEN_MODAL ? '' : 'rounded-2xl'
            }">
                <div class="text-amber-600 animate-pulse">
                    <i class="fas fa-spinner fa-spin text-3xl"></i>
                </div>
            </div>
        `;
        
        modal.classList.remove('hidden');
        
        // Start preloading high-res image immediately
        const recipeWithUserData = this.userDataManager.getRecipeWithUserData(recipe);
        this.preloadHighResImage(recipeWithUserData);
        
        // Clear steps
        this.clearStepsForRecipe(recipeId);
        
        // Render content in next frame for smooth transition
        requestAnimationFrame(() => {
            this.updateModalContent();
            
            // Defer non-critical operations
            this.addPendingTimeout(() => {
                this.userDataManager.trackView(recipeId);
                if (this.urlManager) {
                    this.urlManager.updateURL();
                }
            });
        });
    }

    setupModalLayout() {
        const modal = document.getElementById('recipeModal');
        const flexContainer = modal.firstElementChild;
        const modalWrapper = flexContainer ? flexContainer.firstElementChild : null;
        
        const windowWidth = window.innerWidth;
        this.isFullscreen = windowWidth <= CONFIG.BREAKPOINTS.FULLSCREEN_MODAL;
        
        if (this.isFullscreen) {
            modal.className = 'fixed inset-0 z-50 bg-gradient-to-br from-amber-100 to-orange-100';
            if (flexContainer) {
                flexContainer.className = 'h-full';
            }
            if (modalWrapper) {
                modalWrapper.className = 'h-full w-full flex flex-col relative';
            }
        } else {
            modal.className = 'fixed inset-0 bg-black bg-opacity-50 z-50';
            if (flexContainer) {
                flexContainer.className = 'flex items-center justify-center min-h-screen p-4';
            }
            if (modalWrapper) {
                modalWrapper.className = 'bg-gradient-to-br from-amber-100 to-orange-100 rounded-3xl max-w-5xl w-full h-[92vh] flex flex-col shadow-2xl relative overflow-hidden';
            }
        }
    }

    updateModalLayout() {
        if (this.currentRecipeId) {
            this.setupModalLayout();
        }
    }

    // Optimized hero section with progressive image loading
    generateHeroSection(recipe) {
        const imageLowUrl = recipe.image ? CONFIG.IMAGE_PATHS.LIST + recipe.image : null;
        const imageHighUrl = recipe.image ? CONFIG.IMAGE_PATHS.MODAL + recipe.image : null;
        const isMobile = window.innerWidth <= CONFIG.BREAKPOINTS.SINGLE_COLUMN;
        const heroImageHeight = isMobile ? 'h-56' : 'h-80';
        const isFullscreen = window.innerWidth <= CONFIG.BREAKPOINTS.FULLSCREEN_MODAL;
        
        return `
            <div class="absolute inset-0 bg-gradient-to-br from-amber-100 to-orange-100 ${!isFullscreen ? 'rounded-2xl' : ''} z-0">
                <div class="absolute inset-x-0 top-0 ${heroImageHeight} ${!isFullscreen ? 'rounded-t-2xl overflow-hidden' : ''}">
                    ${recipe.image ? 
                        `<div class="relative w-full h-full">
                            <!-- Low-res loads instantly -->
                            <img src="${imageLowUrl}" 
                                alt="${recipe.title}" 
                                class="w-full h-full object-cover absolute inset-0">
                            <!-- High-res loads progressively -->
                            <img src="${imageHighUrl}" 
                                alt="${recipe.title}" 
                                class="w-full h-full object-cover absolute inset-0 opacity-0"
                                onload="this.style.transition='opacity 0.3s ease-in-out'; this.style.opacity='1';">
                        </div>` : 
                        `<div class="w-full h-full flex items-center justify-center">
                            <span class="text-8xl opacity-30">🍞</span>
                        </div>`}
                    ${recipe.category ? 
                        `<span onclick="recipeApp.filterManager.activateFilter('category', '${recipe.category}', event)" 
                            class="absolute top-4 left-4 bg-white/90 backdrop-blur text-xs md:text-sm font-medium px-2 py-1 md:px-3 md:py-1.5 rounded-full text-amber-700 transition-all duration-200 cursor-pointer hover:scale-105 hover:shadow-lg">
                            ${recipe.category}
                        </span>` : ''}
                </div>
            </div>
        `;
    }

    generateCloseButton() {
        return `
            <button onclick="recipeApp.modalManager.closeRecipe()" 
                    class="absolute top-4 right-4 z-50 bg-white/90 backdrop-blur rounded-full p-2 md:p-2.5 hover:bg-white shadow-lg transition-transform hover:scale-110">
                <i class="fas fa-times text-gray-600 text-lg md:text-xl"></i>
            </button>
        `;
    }

    updateModalContent() {
        if (!this.currentRecipeId) return;
        
        const recipe = this.recipeDatabase.findById(this.currentRecipeId);
        if (!recipe) return;
        
        const recipeWithUserData = this.userDataManager.getRecipeWithUserData(recipe);
        const modalWrapper = document.querySelector('#recipeModal > div > div');
        
        if (!modalWrapper) return;
        
        // Store current scroll position
        const scrollContainer = modalWrapper.querySelector('#scrollableContent');
        const currentScrollTop = scrollContainer ? scrollContainer.scrollTop : 0;
        
        const windowWidth = window.innerWidth;
        const isMobileLayout = windowWidth <= CONFIG.BREAKPOINTS.SINGLE_COLUMN;
        const contentMarginTop = isMobileLayout ? 'mt-48' : 'mt-72';
        
        // Build content
        modalWrapper.innerHTML = `
            ${this.generateHeroSection(recipeWithUserData)}
            ${this.generateCloseButton()}
            <div id="scrollableContent" class="absolute inset-0 overflow-y-auto z-10">
                <div class="${contentMarginTop} min-h-full bg-white rounded-t-3xl shadow-[0_-10px_30px_rgba(0,0,0,0.1)]">
                    ${isMobileLayout ? 
                        this.generateMobileContent(recipeWithUserData) : 
                        this.generateDesktopContent(recipeWithUserData)}
                </div>
            </div>
        `;
        
        // Restore scroll position
        requestAnimationFrame(() => {
            const newScrollContainer = modalWrapper.querySelector('#scrollableContent');
            if (newScrollContainer && currentScrollTop > 0) {
                newScrollContainer.scrollTop = currentScrollTop;
            }
        });
    }

    // Mobile content layout
    generateMobileContent(recipe) {
        const sourceInfo = this.uiManager.formatSource(recipe);
        const today = new Date().toISOString().split('T')[0];
        const madeToday = recipe.madeDates && recipe.madeDates.includes(today);
        const madeCount = recipe.madeDates ? recipe.madeDates.length : 0;
        
        return `
            <div class="px-4 py-6">
                <div class="mb-4">
                    <div class="flex items-start gap-2">
                        <h2 class="font-display text-2xl text-gray-800 ${sourceInfo ? 'mb-1' : 'mb-2'}">${recipe.title}</h2>
                        <button onclick="recipeApp.modalManager.copyRecipeURL('${recipe.id}', event)" 
                                class="text-gray-400 hover:text-gray-600 transition-all duration-200 p-1 flex-shrink-0">
                            <i class="fas fa-copy text-sm"></i>
                        </button>
                    </div>
                    ${sourceInfo ? `
                        <div class="flex items-center gap-2 mb-2">
                            <p class="text-xs text-amber-600">${sourceInfo}</p>
                            ${recipe.pageNumber ? `
                                <button onclick="recipeApp.kokebokViewer.open(${recipe.pageNumber})" 
                                        class="text-amber-600 hover:text-amber-700 transition-colors"
                                        title="Vis oppskrift i kokeboken">
                                    <i class="fas fa-book text-xs"></i>
                                </button>
                            ` : ''}
                        </div>
                    ` : ''}
                    ${this.renderTags(recipe)}
                </div>
                
                <div class="flex items-center justify-between mb-4">
                    <div class="flex items-center gap-2">
                        <button id="eraser-${recipe.id}" 
                                onclick="recipeApp.modalManager.clearRating('${recipe.id}', event)" 
                                class="text-gray-400 hover:text-gray-600 transition-all duration-200 p-1 ${recipe.userRating ? 'opacity-100' : 'opacity-0 pointer-events-none'}">
                            <i class="fas fa-eraser text-lg"></i>
                        </button>
                        <div class="flex items-center">
                            ${this.renderInteractiveStars(recipe)}
                        </div>
                    </div>
                    <div class="flex items-center gap-2">
                        <button onclick="recipeApp.modalManager.toggleTag('${recipe.id}', event)" 
                                class="flex items-center space-x-1 px-3 py-1.5 rounded-lg transition text-xs font-medium
                                    ${recipe.tagged ? 'bg-yellow-600 text-white' : 'border border-gray-300 text-gray-600 hover:bg-gray-50'}">
                            <i class="fas fa-tag"></i>
                        </button>
                        <button onclick="recipeApp.modalManager.toggleMadeToday('${recipe.id}', event)" 
                                class="flex items-center space-x-1 px-3 py-1.5 rounded-lg transition text-xs font-medium
                                    ${madeToday ? 'bg-amber-600 text-white' : 'border border-gray-300 text-gray-600 hover:bg-gray-50'}">
                            <i class="fas fa-check"></i>
                            <span>Laget (${madeCount})</span>
                        </button>
                    </div>
                </div>
                
                ${recipe.description ? `
                    <div class="pb-4 mb-6 border-b border-amber-600">
                        <p class="text-gray-700 text-sm leading-relaxed">${recipe.description}</p>
                    </div>
                ` : ''}
                
                <div class="mb-6 pb-6 border-b border-amber-600">
                    <h3 class="font-display text-xl text-amber-800 mb-3">Ingredienser</h3>
                    ${this.renderIngredients(recipe.ingredients)}
                    <div class="mt-4 flex items-center gap-2 text-amber-600 rounded-lg px-3 py-2 inline-flex">
                        <i class="fas fa-users text-sm"></i>
                        <span class="text-sm font-medium">${recipe.servings}</span>
                    </div>
                </div>
                
                <div class="mb-8">
                    <h3 class="font-display text-xl text-amber-800 mb-3">Slik gjør du</h3>
                    ${this.renderInstructions(recipe.instructions, true)}
                </div>
            </div>
        `;
    }

    generateDesktopContent(recipe) {
        const sourceInfo = this.uiManager.formatSource(recipe);
        const today = new Date().toISOString().split('T')[0];
        const madeToday = recipe.madeDates && recipe.madeDates.includes(today);
        const madeCount = recipe.madeDates ? recipe.madeDates.length : 0;
        
        return `
            <div class="px-8 py-8">
                <div class="border-b border-gray-100 pb-4 mb-6">
                    <div class="flex items-start gap-3">
                        <h2 class="font-display text-3xl text-gray-800 ${sourceInfo ? 'mb-1' : 'mb-2'}">${recipe.title}</h2>
                        <button onclick="recipeApp.modalManager.copyRecipeURL('${recipe.id}', event)" 
                                class="text-gray-400 hover:text-gray-600 transition-all duration-200 p-1.5 flex-shrink-0">
                            <i class="fas fa-copy"></i>
                        </button>
                    </div>
                    ${sourceInfo ? `
                        <div class="flex items-center gap-2 mb-2">
                            <p class="text-xs text-amber-600">${sourceInfo}</p>
                            ${recipe.pageNumber ? `
                                <button onclick="recipeApp.kokebokViewer.open(${recipe.pageNumber})" 
                                        class="text-amber-600 hover:text-amber-700 transition-colors"
                                        title="Vis oppskrift i kokeboken">
                                    <i class="fas fa-book text-xs"></i>
                                </button>
                            ` : ''}
                        </div>
                    ` : ''}
                    ${this.renderTags(recipe)}
                    
                    <div class="flex items-center justify-between">
                        <div class="flex items-center gap-4">
                            <div class="flex items-center gap-2">
                                <button id="eraser-${recipe.id}" 
                                        onclick="recipeApp.modalManager.clearRating('${recipe.id}', event)" 
                                        class="text-gray-400 hover:text-gray-600 transition-all duration-200 p-1 ${recipe.userRating ? 'opacity-100' : 'opacity-0 pointer-events-none'}">
                                    <i class="fas fa-eraser text-xl"></i>
                                </button>
                                <div class="flex items-center gap-1">
                                    ${this.renderInteractiveStars(recipe)}
                                </div>
                            </div>
                        </div>
                        
                        <div class="flex items-center gap-2">
                            <button onclick="recipeApp.modalManager.toggleTag('${recipe.id}', event)" 
                                    class="flex items-center space-x-2 px-4 py-2 rounded-lg transition text-sm font-medium
                                        ${recipe.tagged ? 'bg-yellow-600 text-white hover:bg-yellow-700' : 'border border-gray-300 text-gray-600 hover:bg-gray-50'}">
                                <i class="fas fa-tag"></i>
                                <span>Merk</span>
                            </button>
                            
                            <button onclick="recipeApp.modalManager.toggleMadeToday('${recipe.id}', event)" 
                                    class="flex items-center space-x-2 px-4 py-2 rounded-lg transition text-sm font-medium
                                        ${madeToday ? 'bg-amber-600 text-white hover:bg-amber-700' : 'border border-gray-300 text-gray-600 hover:bg-gray-50'}">
                                <i class="fas fa-check"></i>
                                <span>Laget (${madeCount})</span>
                            </button>
                        </div>
                    </div>
                </div>
                
                ${recipe.description ? `
                    <div class="pb-6 mb-6 border-b border-amber-600">
                        <p class="text-gray-700 leading-relaxed">${recipe.description}</p>
                    </div>
                ` : ''}
                
                <div class="grid md:grid-cols-[2fr,3fr] gap-8">
                    <div class="pr-8 border-r border-amber-600">
                        <h3 class="font-display text-xl text-amber-800 mb-4">Ingredienser</h3>
                        ${this.renderIngredients(recipe.ingredients)}
                        <div class="mt-4 flex items-center gap-2 text-amber-600 rounded-lg px-3 py-2 inline-flex">
                            <i class="fas fa-users"></i>
                            <span class="font-medium">${recipe.servings}</span>
                        </div>
                    </div>
                    
                    <div>
                        <h3 class="font-display text-xl text-amber-800 mb-4">Slik gjør du</h3>
                        ${this.renderInstructions(recipe.instructions, false)}
                    </div>
                </div>
            </div>
        `;
    }

    renderTags(recipe) {
        if (!recipe.cuisine && !recipe.meal) return '';
        
        return `
            <div class="flex gap-2 mb-4">
                ${recipe.cuisine ? 
                    `<span onclick="recipeApp.filterManager.activateFilter('cuisine', '${recipe.cuisine}', event)" 
                        class="inline-block px-2 py-0.5 bg-gray-100 rounded-full text-xs">
                        ${recipe.cuisine} kjøkken
                    </span>` : ''}
                ${recipe.meal ? 
                    `<span onclick="recipeApp.filterManager.activateFilter('meal', '${recipe.meal}', event)" 
                        class="inline-block px-2 py-0.5 bg-gray-100 rounded-full text-xs">
                        ${recipe.meal}
                    </span>` : ''}
            </div>
        `;
    }

    renderIngredients(ingredients) {
        if (!ingredients || ingredients.length === 0) return '';
        
        const hasGroups = ingredients.some(item => typeof item === 'object' && item.group);
        
        if (!hasGroups) {
            return `
                <ul class="space-y-2">
                    ${ingredients.map(ing => `
                        <li class="flex items-start">
                            <span class="text-amber-600 mr-2">•</span>
                            <span class="text-gray-700">${ing}</span>
                        </li>
                    `).join('')}
                </ul>
            `;
        } else {
            return ingredients.map((group, index) => {
                if (typeof group === 'string') {
                    return `
                        <ul class="space-y-2 ${index > 0 ? 'mt-4' : ''}">
                            <li class="flex items-start">
                                <span class="text-amber-600 mr-2">•</span>
                                <span class="text-gray-700">${group}</span>
                            </li>
                        </ul>
                    `;
                }
                
                return `
                    <div class="${index > 0 ? 'mt-5' : ''}">
                        <h4 class="font-semibold text-sm text-amber-700 mb-2">${group.group}:</h4>
                        <ul class="space-y-2">
                            ${group.items.map(ing => `
                                <li class="flex items-start">
                                    <span class="text-amber-600 mr-2">•</span>
                                    <span class="text-gray-700">${ing}</span>
                                </li>
                            `).join('')}
                        </ul>
                    </div>
                `;
            }).join('');
        }
    }

    toggleInstructionStep(recipeId, stepIndex) {
        const key = `${recipeId}-${stepIndex}`;
        const isCompleted = this.completedSteps.get(key) || false;
        const isActive = this.activeStep === key;
        
        const stepElement = document.querySelector(`[data-step="${key}"]`);
        if (!stepElement) return;
        
        if (this.activeStep && this.activeStep !== key) {
            const prevElement = document.querySelector(`[data-step="${this.activeStep}"]`);
            if (prevElement && !this.completedSteps.get(this.activeStep)) {
                prevElement.parentElement.classList.remove('bg-amber-50', 'border-l-4', 'border-amber-500', 'pl-4', 'pr-0');
                prevElement.parentElement.classList.add('pr-2');
                prevElement.classList.remove('text-black');
                prevElement.classList.add('text-gray-700');
            }
        }
        
        if (!isActive && !isCompleted) {
            this.activeStep = key;
            this.completedSteps.delete(key);
            stepElement.classList.remove('line-through', 'text-gray-400');
            stepElement.classList.remove('text-gray-700');
            stepElement.classList.add('text-black');
            stepElement.parentElement.classList.add('bg-amber-50', 'border-l-4', 'border-amber-500', 'pl-4', 'pr-0');
            stepElement.parentElement.classList.remove('pr-2');
        } else if (isActive && !isCompleted) {
            this.completedSteps.set(key, true);
            this.activeStep = null;
            stepElement.classList.add('line-through', 'text-gray-400');
            stepElement.classList.remove('text-black');
            stepElement.parentElement.classList.remove('bg-amber-50', 'border-l-4', 'border-amber-500', 'pl-4', 'pr-0');
            stepElement.parentElement.classList.add('pr-2');
        } else if (isCompleted) {
            this.completedSteps.delete(key);
            this.activeStep = key;
            stepElement.classList.remove('line-through', 'text-gray-400');
            stepElement.classList.add('text-black');
            stepElement.parentElement.classList.add('bg-amber-50', 'border-l-4', 'border-amber-500', 'pl-4', 'pr-0');
            stepElement.parentElement.classList.remove('pr-2');
        }
    }

    renderTip(tipText, isMobile) {
        const textSizeClass = isMobile ? 'text-sm' : '';
        return `
            <li class="bg-gradient-to-r from-yellow-100 to-yellow-50 border-l-[3px] border-amber-500 rounded-lg ${isMobile ? 'px-3 py-2.5' : 'p-3'} animate-[tipHighlight_0.3s_ease-out]">
                <div class="flex items-start">
                    <span class="text-amber-600 mr-2 flex-shrink-0">
                        <i class="fas fa-lightbulb"></i>
                    </span>
                    <div>
                        <span class="font-semibold text-amber-700 mr-2 text-sm">Tips:</span>
                        <span class="text-gray-700 ${textSizeClass}">${tipText}</span>
                    </div>
                </div>
            </li>
        `;
    }

    renderInstructionStep(instruction, stepNumber, globalIndex, isMobile) {
        const recipeId = this.currentRecipeId;
        const textSizeClass = isMobile ? 'text-sm' : '';
        const stepKey = `${recipeId}-${globalIndex}`;
        const isCompleted = this.completedSteps.get(stepKey) || false;
        const isActive = this.activeStep === stepKey;
        
        return `
            <li class="flex items-start cursor-pointer select-none transition-all duration-200 hover:opacity-80 rounded-lg py-2 pl-2 ${isActive ? 'pr-0' : 'pr-2'} -m-2 
                ${isActive ? 'bg-amber-50 border-l-4 border-amber-500 pl-4' : ''}"
                onclick="recipeApp.modalManager.toggleInstructionStep('${recipeId}', ${globalIndex})">
                <span class="font-semibold text-amber-600 mr-3 flex-shrink-0">${stepNumber}.</span>
                <span data-step="${stepKey}" 
                    class="${textSizeClass} ${isCompleted ? 'line-through text-gray-400' : (isActive ? 'text-black' : 'text-gray-700')} transition-all duration-200">
                    ${instruction}
                </span>
            </li>
        `;
    }

    renderInstructionItem(instruction, stepNumber, globalIndex, isMobile) {
        if (typeof instruction === 'string' && (instruction.startsWith('TIP:') || instruction.startsWith('TIPS:'))) {
            const tipText = instruction.replace(/^TIPS?:\s*/i, '');
            return { 
                html: this.renderTip(tipText, isMobile), 
                stepNumber: stepNumber,
                globalIndex: globalIndex 
            };
        }
        
        return { 
            html: this.renderInstructionStep(instruction, stepNumber, globalIndex, isMobile),
            stepNumber: stepNumber + 1,
            globalIndex: globalIndex + 1
        };
    }

    renderInstructions(instructions, isMobile = false) {
        if (!instructions || instructions.length === 0) return '';
        
        let stepNumber = 1;
        let globalIndex = 0;
        
        const hasGroups = instructions.some(item => typeof item === 'object' && item.group);
        
        if (!hasGroups) {
            const items = [];
            instructions.forEach(inst => {
                const result = this.renderInstructionItem(inst, stepNumber, globalIndex, isMobile);
                items.push(result.html);
                stepNumber = result.stepNumber;
                globalIndex = result.globalIndex;
            });
            
            return `<ol class="space-y-3">${items.join('')}</ol>`;
        }
        
        const sections = [];
        
        instructions.forEach((item, index) => {
            if (typeof item === 'string') {
                const result = this.renderInstructionItem(item, stepNumber, globalIndex, isMobile);
                sections.push(`<ol class="space-y-3 ${index > 0 ? 'mt-3' : ''}">${result.html}</ol>`);
                stepNumber = result.stepNumber;
                globalIndex = result.globalIndex;
            } else if (item.group && item.steps) {
                const groupItems = [];
                item.steps.forEach(inst => {
                    const result = this.renderInstructionItem(inst, stepNumber, globalIndex, isMobile);
                    groupItems.push(result.html);
                    stepNumber = result.stepNumber;
                    globalIndex = result.globalIndex;
                });
                
                sections.push(`
                    <div class="${index > 0 ? 'mt-4' : ''}">
                        <h4 class="font-semibold text-sm text-amber-700 mb-2">${item.group}:</h4>
                        <ol class="space-y-2 ${isMobile ? 'pl-3' : 'pl-4'}">
                            ${groupItems.join('')}
                        </ol>
                    </div>
                `);
            }
        });
        
        return sections.join('');
    }

    renderInteractiveStars(recipe) {
        let stars = '';
        const userRating = recipe.userRating || 0;
        for (let i = 1; i <= 5; i++) {
            const filled = i <= userRating;
            stars += `<button onclick="recipeApp.modalManager.rateRecipe('${recipe.id}', ${i}, event)" 
                            class="text-2xl transition-all duration-200 hover:scale-125 hover:text-amber-500">
                <i class="${filled ? 'fas' : 'far'} fa-star ${filled ? 'text-amber-400' : 'text-gray-300'}"></i>
            </button>`;
        }
        return stars;
    }

    closeRecipe() {
        const modal = document.getElementById('recipeModal');
        
        // Cancel all pending operations
        this.cancelPendingTimeouts();
        
        // Clean up event listener timers
        this.cleanupEventListeners();
        
        this.currentRecipeId = null;
        this.isFullscreen = false;
        
        modal.classList.add('hidden');
        
        if (this.urlManager) {
            this.urlManager.updateURL();
        }
        
        document.body.classList.remove('modal-open');
        document.body.style.overflow = '';
        document.body.style.position = '';
        document.documentElement.style.overflow = '';
        
        // Use requestAnimationFrame for smooth scroll restoration
        requestAnimationFrame(() => {
            window.scrollTo(0, this.scrollPosition);
        });
        
        this.resetModalToDefault();
    }

    copyRecipeURL(recipeId, event) {
        if (event) {
            event.stopPropagation();
        }
        
        if (this.urlManager) {
            const url = this.urlManager.getRecipeURL(recipeId);
            const button = event ? event.currentTarget : null;
            this.urlManager.copyToClipboard(url, button);
        }
    }

    resetModalToDefault() {
        const modal = document.getElementById('recipeModal');
        const flexContainer = modal.firstElementChild;
        const modalWrapper = flexContainer ? flexContainer.firstElementChild : null;
        
        modal.className = 'fixed inset-0 bg-black bg-opacity-50 hidden z-50';
        
        if (flexContainer) {
            flexContainer.className = 'flex items-start justify-center min-h-screen sm:pt-8';
        }
        
        if (modalWrapper) {
            modalWrapper.className = 'sm:rounded-2xl max-w-5xl w-full sm:h-[92vh] modal-height-mobile flex flex-col modal-content-mobile';
            modalWrapper.innerHTML = '';
        }
    }

    rateRecipe(recipeId, rating, event) {
        if (event) {
            event.stopPropagation();
        }
        
        this.userDataManager.setRating(recipeId, rating);
        
        const button = event ? event.currentTarget : null;
        if (button && button.parentElement) {
            const stars = button.parentElement.querySelectorAll('i');
            stars.forEach((star, index) => {
                if (index < rating) {
                    star.classList.remove('far', 'text-gray-300');
                    star.classList.add('fas', 'text-amber-400');
                } else {
                    star.classList.remove('fas', 'text-amber-400');
                    star.classList.add('far', 'text-gray-300');
                }
            });
            
            const eraserBtn = document.getElementById(`eraser-${recipeId}`);
            if (eraserBtn && !eraserBtn.classList.contains('opacity-100')) {
                eraserBtn.classList.remove('opacity-0', 'pointer-events-none');
                eraserBtn.classList.add('opacity-100');
            }
        }
        
        this.uiManager.updateRecipeCardRating(recipeId, rating);
        this.recommendationEngine.updateScoreForRecipe(recipeId);
        
        const filterManager = recipeApp.filterManager;
        if (filterManager.sortOrder === 'recommendation' || filterManager.sortOrder === 'rating') {
            // Defer the re-sort to avoid blocking UI
            this.addPendingTimeout(() => filterManager.applyFilters());
        }
    }

    clearRating(recipeId, event) {
        if (event) {
            event.stopPropagation();
        }
        
        this.userDataManager.clearRating(recipeId);
        
        const eraserBtn = document.getElementById(`eraser-${recipeId}`);
        if (eraserBtn) {
            eraserBtn.classList.remove('opacity-100');
            eraserBtn.classList.add('opacity-0', 'pointer-events-none');
            const starsContainer = eraserBtn.nextElementSibling;
            if (starsContainer) {
                const stars = starsContainer.querySelectorAll('button');
                stars.forEach(star => {
                    star.innerHTML = '<i class="far fa-star text-gray-300"></i>';
                });
            }
        }
        
        this.uiManager.updateRecipeCardRating(recipeId, 0);
        this.recommendationEngine.updateScoreForRecipe(recipeId);
        
        const filterManager = recipeApp.filterManager;
        if (filterManager.sortOrder === 'recommendation' || filterManager.sortOrder === 'rating') {
            // Defer the re-sort
            this.addPendingTimeout(() => filterManager.applyFilters());
        }
    }

    toggleMadeToday(recipeId, event) {
        if (event) {
            event.stopPropagation();
        }
        
        const result = this.userDataManager.toggleMadeToday(recipeId);
        
        const button = event ? event.currentTarget : document.querySelector(`button[onclick*="toggleMadeToday('${recipeId}'"]`);
        
        if (button) {
            const isMobileLayout = window.innerWidth <= CONFIG.BREAKPOINTS.SINGLE_COLUMN;
            
            button.className = `flex items-center ${isMobileLayout ? 'space-x-1' : 'space-x-2'} px-3 py-1.5 rounded-lg transition ${isMobileLayout ? 'text-xs' : 'text-sm'} font-medium ${
                result.madeToday 
                    ? 'bg-amber-600 text-white' + (!isMobileLayout ? ' hover:bg-amber-700' : '')
                    : 'border border-gray-300 text-gray-600 hover:bg-gray-50'
            }`;
            
            button.innerHTML = `
                <i class="fas fa-check"></i>
                <span>Laget (${result.madeCount})</span>
            `;
        }
        
        this.uiManager.updateRecipeCardCounter(recipeId, result.madeCount);
        this.recommendationEngine.updateScoreForRecipe(recipeId);
        
        const filterManager = recipeApp.filterManager;
        if (filterManager.sortOrder === 'recommendation' || filterManager.sortOrder === 'madecount') {
            // Defer the re-sort
            this.addPendingTimeout(() => filterManager.applyFilters());
        }
    }

    toggleTag(recipeId, event) {
        if (event) {
            event.stopPropagation();
        }
        
        const isTagged = this.userDataManager.toggleTag(recipeId);
        
        const button = event ? event.currentTarget : document.querySelector(`button[onclick*="toggleTag('${recipeId}'"]`);
        
        if (button) {
            const isMobileLayout = window.innerWidth <= CONFIG.BREAKPOINTS.SINGLE_COLUMN;
            
            button.className = `flex items-center ${isMobileLayout ? 'space-x-1' : 'space-x-2'} px-3 py-1.5 rounded-lg transition ${isMobileLayout ? 'text-xs' : 'text-sm'} font-medium ${
                isTagged 
                    ? 'bg-yellow-600 text-white' + (!isMobileLayout ? ' hover:bg-yellow-700' : '')
                    : 'border border-gray-300 text-gray-600 hover:bg-gray-50'
            }`;
            
            button.innerHTML = `
                <i class="fas fa-tag"></i>
                ${!isMobileLayout ? '<span>Merk</span>' : ''}
            `;
        }
        
        this.uiManager.updateRecipeCardTag(recipeId, isTagged);
        
        // Defer the re-sort to avoid blocking UI
        this.addPendingTimeout(() => {
            const filterManager = recipeApp.filterManager;
            filterManager.applyFilters();
        });
    }
}

// ============================================================================
// RECOMMENDATION ENGINE CLASS
// ============================================================================

class RecommendationEngine {
    constructor(recipeDatabase, userDataManager, uiManager) {
        this.recipeDatabase = recipeDatabase;
        this.userDataManager = userDataManager;
        this.uiManager = uiManager;
        this.recipeScores = new Map();
    }

    calculateAllScores() {
        // Clear existing scores to force fresh calculation
        this.recipeScores.clear();
        
        const recipeIds = this.recipeDatabase.getAllIds();
        
        recipeIds.forEach(id => {
            const score = this.calculateRecipeScore(id);
            this.recipeScores.set(id, score);
        });
    }

    calculateRecipeScore(recipeId) {
        const recipe = this.recipeDatabase.findById(recipeId);
        const userData = this.userDataManager.getRecipeData(recipeId);
        
        // Weight configuration - adjust these to change importance
        const WEIGHTS = {
            BASE: 20,                 // Base score everyone starts with
            USER_RATING: 10,          // 0-50 points (rating * multiplier)
            NEVER_VIEWED: 30,         // 30 points bonus
            MADE_COUNT: 5,            // 0-10 points based on how often made
            NOSTALGIA_BONUS: 10,      // Bonus for old views
            
            // Recency multipliers (applied to base score portion)
            RECENCY_TODAY: 0.1,       // Viewed today
            RECENCY_RECENT: 0.3,      // 1-3 days ago
            RECENCY_WEEK: 0.6,        // 3-7 days ago
            RECENCY_NORMAL: 1.0,      // 7-30 days ago
            
            // Category multipliers (applied to total score)
            JULEKAKER_CHRISTMAS: 3.0,    // Nov-Dec multiplier
            JULEKAKER_JANUARY: 1.5,      // January multiplier
            JULEKAKER_OFF_SEASON: 0.05,  // Feb-Oct multiplier  
            SLAKTEVEILEDNING: 0.01,      // Year-round penalty
        };
        
        // Start with base score
        let score = WEIGHTS.BASE;
        
        // Add user rating bonus (0 to 50 based on 1-5 star rating)
        if (userData.userRating) {
            score += userData.userRating * WEIGHTS.USER_RATING;
        }
        
        // Add discovery bonus - never viewed recipes get a boost
        if (!userData.lastViewed) {
            score += WEIGHTS.NEVER_VIEWED;
        }
        
        // Apply recency multiplier (reduces score for recent views)
        let recencyMultiplier = WEIGHTS.RECENCY_NORMAL;
        
        if (userData.lastViewed) {
            const now = new Date();
            const viewedDate = new Date(userData.lastViewed);
            const daysSinceView = (now - viewedDate) / (1000 * 60 * 60 * 24);
            
            if (daysSinceView < 1) {
                // Viewed today - heavy reduction
                recencyMultiplier = WEIGHTS.RECENCY_TODAY;
            } else if (daysSinceView < 3) {
                // 1-3 days ago - moderate reduction
                recencyMultiplier = WEIGHTS.RECENCY_RECENT;
            } else if (daysSinceView < 7) {
                // 3-7 days ago - light reduction
                recencyMultiplier = WEIGHTS.RECENCY_WEEK;
            } else if (daysSinceView > 30) {
                // Over a month ago - add nostalgia bonus
                score += WEIGHTS.NOSTALGIA_BONUS;
            }
        }
        
        // Apply recency multiplier
        score *= recencyMultiplier;
        
        // Add popularity bonus - frequently made recipes
        if (userData.madeDates && userData.madeDates.length > 0) {
            // Cap at 10 points max (if made 10+ times)
            const madeBonus = Math.min(userData.madeDates.length, 10) * (WEIGHTS.MADE_COUNT / 10);
            score += madeBonus;
        }
        
        // Apply category-based multipliers
        if (recipe) {
            // Christmas cakes - seasonal adjustment
            if (recipe.category === 'Julekaker') {
                const now = new Date();
                const month = now.getMonth(); // 0 = January, 11 = December
                
                if (month === 10 || month === 11) {
                    // November & December - prime season
                    score *= WEIGHTS.JULEKAKER_CHRISTMAS;
                } else if (month === 0) {
                    // January - still acceptable
                    score *= WEIGHTS.JULEKAKER_JANUARY;
                } else {
                    // February through October - heavily penalized
                    score *= WEIGHTS.JULEKAKER_OFF_SEASON;
                }
            }
            
            // Preserves - always deprioritized
            if (recipe.category === 'Slakteveiledning') {
                score *= WEIGHTS.SLAKTEVEILEDNING;
            }
        }
        
        // Ensure minimum score of 0
        return Math.max(score, 0);
    }

    getRecipeScore(recipeId) {
        // Return cached score if available
        if (this.recipeScores.has(recipeId)) {
            return this.recipeScores.get(recipeId);
        }
        
        // Calculate and cache the score
        const score = this.calculateRecipeScore(recipeId);
        this.recipeScores.set(recipeId, score);
        return score;
    }

    updateScoreForRecipe(recipeId) {
        // Recalculate score for a specific recipe (e.g., after rating/making it)
        const score = this.calculateRecipeScore(recipeId);
        this.recipeScores.set(recipeId, score);
    }
}

// ============================================================================
// MAIN APPLICATION CLASS
// ============================================================================

class RecipeApp {
    constructor() {
        // Initialize core components
        this.recipeDatabase = new RecipeDatabase();
        this.userDataManager = new UserDataManager();
        this.uiManager = new UIManager(this.recipeDatabase, this.userDataManager);
        this.recommendationEngine = new RecommendationEngine(
            this.recipeDatabase, 
            this.userDataManager, 
            this.uiManager
        );
        
        // Initialize managers that depend on other components
        this.filterManager = new FilterManager(
            this.recipeDatabase, 
            this.uiManager,
            this.recommendationEngine,
            this.userDataManager
        );
        this.kokebokViewer = new KokebokViewer();
        this.modalManager = new ModalManager(
            this.recipeDatabase, 
            this.userDataManager, 
            this.uiManager,
            this.recommendationEngine
        );
        
        // Initialize URL Manager
        this.urlManager = new URLManager(
            this.filterManager,
            this.modalManager,
            this.recipeDatabase
        );
        
        // Connect URL manager to other managers
        this.filterManager.setURLManager(this.urlManager);
        this.modalManager.setURLManager(this.urlManager);
        
        // Set up the modal callback in UIManager
        this.uiManager.setModalCallback((recipeId) => {
            this.modalManager.showRecipe(recipeId);
        });
        
        // Setup event listeners
        this.filterManager.setupEventListeners();
        this.urlManager.setupHistoryListener();
        
        // Initialize the app
        this.init();
    }

    init() {
        // Calculate initial recommendation scores
        this.recommendationEngine.calculateAllScores();
        
        // Initialize from URL parameters
        this.urlManager.initializeFromURL();
        
        // Initial render with recommendation sorting
        this.filterManager.updateFilterButton();
        this.filterManager.applyFilters();
        this.uiManager.setupLazyLoading();
    }
}

// ============================================================================
// INITIALIZE APPLICATION
// ============================================================================

// Create global instance for onclick handlers
let recipeApp;

// Initialize when DOM is ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
        recipeApp = new RecipeApp();
    });
} else {
    recipeApp = new RecipeApp();
}
</script>
</body>
</html>